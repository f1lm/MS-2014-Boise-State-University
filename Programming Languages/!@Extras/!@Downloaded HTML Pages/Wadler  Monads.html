
<!-- saved from url=(0055)http://homepages.inf.ed.ac.uk/wadler/topics/monads.html -->
<html class=""><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Wadler: Monads</title>
<link rel="stylesheet" type="text/css" href="./Wadler  Monads_files/style.css">
<!-- Changed by: Philip Wadler,  7-May-1996 -->

<style type="text/css"></style><link rel="stylesheet" type="text/css" href="chrome-extension://cgndfbhngibokieehnjhbjkkhbfmhojo/css/validation.css"><style type="text/css">.fancybox-margin{margin-right:0px;}</style></head><body data-gclp-initialized="true" data-gistbox-initialized="true"><h1>Monads, Arrows, and Idioms</h1>

<h2>Philip Wadler</h2>

<hr>

<a name="arrows"><h3>The arrow calculus</h3></a>
Sam Lindley, Philip Wadler, and Jeremy Yalloop,
<em>Journal of Functional Programming</em> 20(1):51&amp;em;69, 2010.

<p>
We introduce the arrow calculus, a metalanguage for manipulating
Hughes’s arrows with close relations both to Moggi’s metalanguage for
monads and to Paterson’s arrow notation.  Arrows are classically
defined by extending lambda calculus with three constructs satisfying
nine (somewhat idiosyncratic) laws; in contrast, the arrow calculus
adds four constructs satisfying five laws (which fit two well-known
patterns). The five laws were previously known to be sound; we show
that they are also complete, and hence that the five laws may replace
the nine.
</p>

<h4>
Available in:
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/arrows-jfp/arrows-jfp.pdf">pdf</a>,
<a href="http://dx.doi.org/doi:10.1017/S095679680999027X">doi</a>.
</h4>

<hr>

<a name="constraints"><h3>Monadic constraint programming</h3></a>
Tom Schrijvers, Peter Stuckey, and Philip Wadler
<em>Journal of Functional Programming</em> 19(6):663&amp;em;697, 2009.

<p>
A constraint programming system combines two essential components: a
constraint solver and a search engine. The constraint solver reasons
about satisfiability of conjunctions of constraints, and the search
engine controls the search for solutions by iteratively exploring a
disjunctive search tree defined by the constraint program. In this
paper we give a monadic definition of constraint programming in which
the solver is defined as a monad threaded through the monadic search
tree. We are then able to define search and search strategies as
first-class objects that can themselves be built or extended by
composable search transformers.  Search transformers give a powerful
and unifying approach to viewing search in constraint programming, and
the resulting constraint programming system is first class and
extremely flexible.
</p>

<h4>
Available in:
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/constraints/constraints.pdf">pdf</a>,
<a href="http://dx.doi.org/doi:10.1017/S0956796809990086">doi</a>.
</h4>

<hr>

<a name="arrows-and-idioms"><h3>Idioms are oblivious, arrows are meticulous,
   monads are promiscuous</h3></a>
Sam Lindley, Philip Wadler, Jeremy Yallop.
MSFP 2008.

<p>
  We revisit the connection between three notions of computation:
  Moggi's <em>monads</em>, Hughes's <em>arrows</em> and McBride and
  Paterson's <em>idioms</em> (also called <em>applicative functors</em>).
  We show that idioms are equivalent to arrows that satisfy the type
  isomorphism <tt>A ~&gt; B = 1 ~&gt; (A -&gt; B)</tt> and that monads
  are equivalent to arrows that satisfy the type isomorphism
  <tt>A ~&gt; B = A -&gt; (1 ~&gt; B)</tt>.  Further, idioms embed into arrows and
  arrows embed into monads.
</p>

<h4>
Available in:
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf">pdf</a>. 
</h4>

<hr>

<a name="effectstocl"><h3>The marriage of effects and monads</h3></a>
Philip Wadler and Peter Thiemann.
<em>ACM Transactions on Computational Logic</em>, 4(1):1-32, January 2003.
<p>

Gifford and others proposed an <em>effect</em> typing discipline to
delimit the scope of computational effects within a program, while
Moggi and others proposed <em>monads</em> for much the same purpose.
Here we marry effects to monads, uniting two previously separate lines
of research.  In particular, we show that the type, region, and effect
system of Talpin and Jouvelot carries over directly to an analogous
system for monads, including a type and effect reconstruction algorithm.  The
same technique should allow one to transpose any effect systems into a
corresponding monad system.

</p><p>This is the journal version of the
<a href="http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#effects">ICFP effects paper</a>.

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effectstocl/effectstocl.pdf">pdf</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effectstocl/effectstocl.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effectstocl/effectstocl.ps">ps</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effectstocl/effectstocl.dvi.gz">dvi.gz</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effectstocl/effectstocl.ps.gz">ps.gz</a>,
<a href="http://doi.acm.org/10.1145/601775.601776">ACM portal</a>.
</h4>

<hr>

<a name="effects"><h3>The marriage of effects and monads</h3></a>
Philip Wadler.
<em>International Conference on Functional Programming</em>,
Baltimore, September 1998.
<p>

This is the conference version of the
<a href="http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#effectstocl">ToCL paper</a>.

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effects/effects.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effects/effects.ps">ps</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effects/effects.dvi.gz">dvi.gz</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/effects/effects.ps.gz">ps.gz</a>,
<a href="http://doi.acm.org/10.1145/289423.289429">ACM portal</a>.
</h4>

<hr>

<a name="monadsdeclare"><h3>How to declare an imperative</h3></a>

Philip Wadler.

<em>ACM Computing Surveys</em>, 29(3):240--263, September 1997.
A shorter version was an invited paper at ILPS 95,
appearing in John Lloyd, editor, <em> International
Logic Programming Symposium</em>, MIT Press, December 1995.
<p>

This tutorial describes the use of a <em>monad</em> to integrate
interaction into a purely declarative language.  This technique has
been implemented in the higher-order functional language Haskell.  A
sketch is given of how it might be added to a first-order language for
logic programming. </p><p>

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monadsdeclare/monadsdeclare.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monadsdeclare/monadsdeclare.ps">ps</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monadsdeclare/monadsdeclare.dvi.gz">dvi.gz</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monadsdeclare/monadsdeclare.ps.gz">ps.gz</a>,
<a href="http://doi.acm.org/10.1145/262009.262011">ACM portal</a>.
</h4>

<hr>

<a name="composable"><h3>Monads and composable continuations</h3></a>

Philip Wadler.

<em>Lisp and Symbolic Computation</em>, Special issue on
continuations, 7(1):39-56, January 1994. <p>

Moggi's use of monads to factor semantics is used to model the
composable continuations of Danvy and Filinski.  This yields some
insights into the type systems proposed by Murthy and by Danvy and
Filinski.  Interestingly, modelling some aspects of composable
continuations requires a structure that is almost, but not quite, a
monad. </p><p>

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/composable/composable.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/composable/composable.ps">ps</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/composable/composable.dvi.gz">dvi.gz</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/composable/composable.ps.gz">ps.gz</a>.
</h4>

<hr>

<a name="imperative"><h3>Imperative functional programming</h3></a>

Simon Peyton Jones and Philip Wadler.

<em> 20'th Symposium on Principles of Programming Languages</em>, ACM
Press, Charlotte, North Carolina, January 1993. <p>

We present a new model, based on monads, for performing input/output
in a non-strict, purely functional language.  It
is composable, extensible, efficient, requires no extensions
to the type system, and extends smoothly to incorporate mixed-language
working and in-place array updates. </p><p>

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/imperative/imperative.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/imperative/imperative.ps">ps</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/imperative/imperative.dvi.gz">dvi.gz</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/imperative/imperative.ps.gz">ps.gz</a>,
<a href="http://doi.acm.org/10.1145/158511.158524">ACM portal</a>.
</h4>

<hr>

<a name="marktoberdorf"><h3>Monads for functional programming</h3></a>

Philip Wadler.

In M. Broy, editor, <em>Marktoberdorf Summer School on Program Design
Calculi</em>, Springer Verlag, NATO ASI Series F: Computer and systems
sciences, Volume 118, August 1992.  Also in J. Jeuring and E. Meijer,
editors, <em>Advanced Functional Programming</em>, Springer Verlag,
LNCS 925, 1995.  Some errata fixed August 2001.<p>

The use of monads to structure functional programs is described.
Monads provide a convenient framework for simulating effects found in
other languages, such as global state, exception handling, output, or
non-determinism.  Three case studies are looked at in detail: how
monads ease the modification of a simple evaluator; how monads act as
the basis of a datatype of arrays subject to in-place update; and how
monads can be used to build parsers. </p><p>

Keywords: programming languages / functional programming / category
theory / monads / pure vs. impure functional languages / semantics /
state / parsers. </p><p>

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">pdf</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.ps">ps</a> 
</h4>

<hr>

<a name="monads"><h3>Comprehending monads</h3></a>

Philip Wadler.

<em>Mathematical Structures in Computer Science</em>,
Special issue of selected papers from <em>6'th Conference
on Lisp and Functional Programming</em>, 2:461-493, 1992. <p>

Category theorists invented <em>monads</em> in the 1960's to concisely
express certain aspects of universal algebra.  Functional programmers
invented <em>list comprehensions</em> in the 1970's to concisely
express certain programs involving lists.  This paper shows how list
comprehensions may be generalised to an arbitrary monad, and how the
resulting programming feature can concisely express in a pure
functional language some programs that manipulate state, handle
exceptions, parse text, or invoke continuations.  A new solution to
the old problem of destructive array update is also presented.  No
knowledge of category theory is assumed. </p><p>

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monads/monads.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monads/monads.ps">ps</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monads/monads.dvi.gz">dvi.gz</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monads/monads.ps.gz">ps.gz</a>.
</h4>

<hr>

<a name="combining-monads"><h3>Combining monads</h3></a>

David King and Philip Wadler.

<em>Glasgow Workshop on Functional Programming</em>,
Springer Verlag Workshops in Computing Series,
Ayr, July 1992. <p>

Monads provide a way of structuring functional programs. Most real
applications require a combination of primitive monads. Here we
describe how some monads may be combined with others to yield a
<em>combined monad</em>. </p><p>

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monadscomb/monadscomb.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monadscomb/monadscomb.ps">ps</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monadscomb/monadscomb.dvi.gz">dvi.gz</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/monadscomb/monadscomb.ps.gz">ps.gz</a>.
</h4>

<hr>

<a name="essence"><h3>The essence of functional programming</h3></a>

Philip Wadler.

Invited talk, <em>19'th Symposium on Principles of Programming
Languages</em>, ACM Press, Albuquerque, January 1992. <p>

This paper explores the use monads to structure functional programs.
No prior knowledge of monads or category theory is required. </p><p>

Monads increase the ease with which programs may be modified.  They
can mimic the effect of impure features such as exceptions, state, and
continuations; and also provide effects not easily achieved with such
features.  The types of a program reflect which effects occur. </p><p>

The first section is an extended example of the use of monads.  A
simple interpreter is modified to support various extra features:
error messages, state, output, and non-deterministic choice.  The
second section describes the relation between monads and
continuation-passing style.  The third section sketches how monads are
used in a compiler for Haskell that is written in Haskell. </p><p>

</p><h4>Available in: 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.dvi">dvi</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps">ps</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.dvi.gz">dvi.gz</a>, 
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps.gz">ps.gz</a>,
<a href="http://doi.acm.org/10.1145/143165.143169">ACM portal</a>.
</h4>

<hr> <p>

</p><h2>See also</h2>

<ul>

<li>
<a href="http://homepages.inf.ed.ac.uk/wadler/topics/linear-logic.html#linearmonad">Linear logic, monads, and the
lambda calculus</a>.
Nick Benton, Philip Wadler.  <em>11'th IEEE Symposium
on Logic in Computer Science</em>, New Brunswick,
New Jersey, July 1996. <p>

</p></li><li> 
<a href="http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html#lazyvsstrict">Lazy <em>vs.</em> strict</a>.
Philip Wadler.
<em>ACM Computing Surveys</em>, June 1996.   <p>

</p></li><li> 
<a href="http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html#reflection">A reflection on call-by-value</a>.
Amr Sabry and Philip Wadler.
<em>International Conference on Functional Programming</em>,
ACM Press, Philadelphia, May 1996.   <p>

</p></li></ul>

<hr> <p>

</p><address>
<a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a>, 
<img align="top" src="./Wadler  Monads_files/wadler.gif">
</address>

<iframe frameborder="0" scrolling="no" style="border: 0px; display: none; background-color: transparent;"></iframe><div id="GOOGLE_INPUT_CHEXT_FLAG" style="display: none;"></div><div id="html-validator-loading"><img src="chrome-extension://cgndfbhngibokieehnjhbjkkhbfmhojo/images/loading.gif">Validating...</div><div id="html-validator-message"><span id="html-validation-message-close">X</span><div id="html-validator-message-content"></div></div><form id="gclp-frame-form" target="gclp-frame" method="post" style="display: none;"></form></body></html>