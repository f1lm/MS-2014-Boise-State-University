// Generated by CoffeeScript 1.7.1
(function() {
  var Lexer, Lua, Moon, builtins, escape_html, is_alpha, unescape_html, wrap_word,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  is_alpha = function(str) {
    return str.match(/^[a-zA-Z_]+$/);
  };

  wrap_word = function(str) {
    if (is_alpha(str)) {
      return "\\b" + str + "\\b";
    } else {
      return str;
    }
  };

  unescape_html = function(text) {
    var node;
    node = document.createElement("div");
    node.innerHTML = text;
    if (node.childNodes.length > 0) {
      return node.childNodes[0].nodeValue;
    } else {
      return "";
    }
  };

  escape_html = function(text) {
    return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  };

  Lexer = (function() {
    Lexer.prototype.attr_name = "class";

    function Lexer() {
      var comp, i, literal_matches, matches, name, p, pattern, pattern_matches, patterns, _i, _len, _ref;
      this.match_name_table = [];
      literal_matches = [];
      pattern_matches = [];
      _ref = this.matches;
      for (name in _ref) {
        patterns = _ref[name];
        if (!(patterns instanceof Array)) {
          patterns = [patterns];
        }
        for (_i = 0, _len = patterns.length; _i < _len; _i++) {
          p = patterns[_i];
          if (p instanceof RegExp) {
            pattern_matches.push([name, p.source]);
          } else {
            literal_matches.push([name, this.escape(p)]);
          }
        }
      }
      comp = function(a, b) {
        return b[1].length - a[1].length;
      };
      literal_matches.sort(comp);
      pattern_matches.sort(comp);
      matches = literal_matches.concat(pattern_matches);
      matches = (function() {
        var _j, _ref1, _ref2, _results;
        _results = [];
        for (i = _j = 0, _ref1 = matches.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = matches[i], name = _ref2[0], pattern = _ref2[1];
          this.match_name_table.push(name);
          _results.push("(" + wrap_word(pattern) + ")");
        }
        return _results;
      }).call(this);
      this.patt = matches.join("|");
      this.r = new RegExp(this.patt, "g");
      this.replace_all();
    }

    Lexer.prototype.replace_all = function() {
      var cls_name, node, nodes, _i, _len, _results;
      cls_name = "." + this.name + "-code";
      nodes = document.querySelectorAll(cls_name);
      _results = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        _results.push(node.innerHTML = this.format_text(unescape_html(node.innerHTML)));
      }
      return _results;
    };

    Lexer.prototype.format_text = function(text) {
      return text.replace(this.r, (function(_this) {
        return function() {
          var i, match, name, params;
          match = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          i = 0;
          while (!params[i] && i < params.length) {
            i++;
          }
          name = _this.match_name_table[i];
          return _this.style(match, _this.get_style(name, match));
        };
      })(this));
    };

    Lexer.prototype.get_style = function(name, value) {
      var fn, _ref;
      fn = ((_ref = this.theme) != null ? _ref[name] : void 0) || ("l_" + name);
      if (typeof fn === "function") {
        return fn(value);
      } else {
        return fn;
      }
    };

    Lexer.prototype.style = function(text, style) {
      text = escape_html(text);
      return "<span " + this.attr_name + "=\"" + style + "\">" + text + "</span>";
    };

    Lexer.prototype.escape = function(text) {
      return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    };

    return Lexer;

  })();

  builtins = ["table.insert", "assert", "print", "ipairs", "pairs", "require", "module", "package.seeall"];

  Lua = (function(_super) {
    __extends(Lua, _super);

    function Lua() {
      return Lua.__super__.constructor.apply(this, arguments);
    }

    Lua.prototype.name = "lua";

    Lua.prototype.matches = {
      fn_symbol: ["function"],
      keyword: ["for", "end", "local", "if", "then", "return", "do", "and", "or", "else", "not", "while", "elseif", "break"],
      special: ["nil", "true", "false"],
      symbol: ['=', '.', '{', '}', ':'],
      builtins: builtins,
      atom: /[_A-Za-z][_A-Za-z0-9]*/,
      number: /-?\d+/,
      string: [/"[^"]*"/, /\[\[.*?]]/],
      comment: /--[^\n]*(?:\n|$)/
    };

    return Lua;

  })(Lexer);

  Moon = (function(_super) {
    __extends(Moon, _super);

    function Moon() {
      return Moon.__super__.constructor.apply(this, arguments);
    }

    Moon.prototype.name = "moon";

    Moon.prototype.matches = {
      keyword: ["class", "extends", "if", "then", "super", "do", "with", "import", "export", "while", "elseif", "return", "for", "in", "from", "when", "using", "else", "and", "or", "not", "switch", "break", "continue"],
      special: ["nil", "true", "false"],
      builtins: builtins,
      self: ["self"],
      symbol: ['!', '\\', '=', '+=', '-=', '...', '*', '>', '<', '#'],
      bold_symbol: [':', '.'],
      fn_symbol: ['->', '=>', '}', '{', '[', ']'],
      self_var: /@[a-zA-Z_][a-zA-Z_0-9]*/,
      table_key: /[_A-Za-z][a-zA-Z_0-9]*(?=:)/,
      proper: /[A-Z][a-zA-Z_0-9]*/,
      atom: /[_A-Za-z]\w*/,
      number: /-?\d+/,
      string: [/"[^"]*"/, /\[\[.*?]]/],
      comment: /--[^\n]*(?:\n|$)/
    };

    return Moon;

  })(Lexer);

  window.Lexer = Lexer;

  window.Lua = Lua;

  window.Moon = Moon;

}).call(this);
