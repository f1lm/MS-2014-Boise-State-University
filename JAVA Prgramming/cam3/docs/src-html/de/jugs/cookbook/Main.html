<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <title>Source code of the sample server application Cookbook</title>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Christoph Mueller">
   <meta name="GENERATOR" content="Mozilla/4.5 [de] (WinNT; I) [Netscape]">
   <meta http-equiv="KEYWORDS" content="Source code, Server application, sample, Java, Linux, MySQL">
   <meta name="Audience" content="IT, Software engineers, Programmer">
   <meta name="Content-Language" content="en-US">
   <meta http-equiv="AUTHOR" content="Christoph Mueller">
   <meta name="COPYRIGHT" content="Christoph Mueller">
   <meta http-equiv="Reply-to" content="CMueller@de.must.de">
   <meta name="PUBLISHER" content="Christoph Mueller">
   <meta name="PUBLISHER-EMAIL" content="CMueller@de.must.de">
   <meta name="CREATION" content="Wdn, 13 Jun 2001">
   <meta name="REVISON" content="Wdn, 15 Aug 2001">
   <meta name="ROBOTS" content="INDEX, FOLLOW">
   <meta name="REVISIT-AFTER" content="28 days">
   <meta name="Description" content="Create reliable database applications easyly - swing and browser by identical concept">
   <meta name="KeyWords" content="Source code, Server application, sample, Java, Linux, MySQL">
</head>
<body background="indtextb.jpg">

<pre>
<h1>Main</h1>
package de.jugs.cookbook;

import de.must.markup.MainStd;


/**
 * This is the only class directly visible to the user. All requests pass this
 * gate. Cameleon OSP will try to assign an existing session. If not possible,
 * a new session is created and assigned.
 * <br>
 * <br> May I suggest one thing? Do not try to understand the sample application
 *      primarily by following the path how the request is worked off. Instead,
 *      try to follow this imagination:
 * <br> 1. For each application fragment: Which type of module is it?
 *         How is it supported by the framework?
 * <br> 2. What does a framework need to know at least, to build the
 *         application you want to create?
 * <br> 3. Where could the framework ask me for details, which it cannot know
 *         by standard?
 * <br>
 * The technical way to realize this paradigm is using the modifier abstract
 * – inside the super classes individual information are requested that way.
 * Your application is demanded to provide the information. E.g. in this class,
 * the framework is asking you:
 * <br> 1. What are your global objects? I need to know your database
 *         connection!
 * <br> 2. What is your session class? I need to know which layout you want to
 *         use and which menu items and toolbar option you like ...
 * <br> Hint: to keep the documentation maintainable, method descriptions are
 * to be found inside the framework components. Look in the API doc of the super
 * class to understand what the framework wants from you. Thus, we haven't this
 * documentation redundantly in each application. And it keeps the individual
 * classes small, which increases clearness.
 * @author Christoph Mueller
 */
public final class Main extends MainStd {

  protected Class<Session> getSessionClass() {
    return Session.class;
  }

  protected void initWithFirstRequestInfos(String realPath) {
    Global.getInstance().createOrCheckConnections();
  }

}

</pre>

<hr WIDTH="100%">
<center> Source is part of the <a href="http://www.must.de/Jacompe.htm" TARGET="_top">Open Source Project Cameleon OSP</a></center>

</body>
</html>
