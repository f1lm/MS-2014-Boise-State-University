(function($) {
	function do_all_client_side_twitter_oembed() {	
		if( typeof twttr === undefined ) {
			$.getScript('//platform.twitter.com/widgets.js', function() { $( '.pending-tweet' ).each( do_client_side_twitter_oembed ); } );
		}
	}

	// handle failed tweets or tweets that haven't been fetched yet
	function do_client_side_twitter_oembed() {
		var $this = $(this),
			text,
			url = 'https://api.twitter.com/1/statuses/oembed.json?omit_script=true&callback=?&';

		// Handle instances where make_clickable gets too friendly and linkifies our Twitter URL 
		if ( $this.has( 'a' ).length ) {
			text = $this.find( 'a' ).first().attr( 'href' );
		} else {
			text = $this.text();
		}
			
		// If we find an exact match, we want to fetch its content from the oembed endpoint and display it
		if ( text.match( /^http(s|):\/\/twitter\.com(\/\#\!\/|\/)([a-zA-Z0-9_]{1,20})\/status(es)*\/(\d+)$/ ) ) {
			url += 'url=' + encodeURIComponent( text );
		} else if ( text.match( /^(\d+)$/ ) ) {
			url += 'id=' + text;
		} else {
			return;
		}

		// Need to make a JSONP call to avoid CORS issues
		$.getJSON( url, function( data ) {
			if ( data.html ) {
				$this.html( data.html );
				$this.show();
				twttr.widgets.load();
			}
		} );
	}

	$( document ).ready( do_all_client_side_twitter_oembed );
	$( document.body ).on('post-load', do_all_client_side_twitter_oembed );
})(jQuery);
;
jQuery( document.body ).on( 'post-load', function() {
	if ( typeof twttr == 'object' && twttr.widgets && twttr.widgets.load )
		twttr.widgets.load();
});;
gigaom.nav = {
	animating: false,
	swipe_x_start: null,
	swipe_x_latest: null,
	window_width: 0
};

( function( $ ) {
	"use strict";

	gigaom.nav.init = function() {
		gigaom.nav.panels = {
			primary: {
				name: 'primary',
				direction: 'left',
				control: '#nav-toggle'
			},
			follow: {
				name: 'follow',
				direction: 'right',
				control: 'body:not(.go-device-full) .nav-plus a'
			}
		};

		gigaom.nav.$search = $('.nav-search');
		gigaom.nav.$search_field = gigaom.nav.$search.find('input');
		gigaom.nav.$sidepanels = $('.sidepanel');
		gigaom.nav.$sidepanel = $('.sidepanel');
		gigaom.nav.$sidepanel_links = gigaom.nav.$sidepanels.find('a');
		gigaom.nav.drag_distance = 0;
		gigaom.nav.direction = null;
		gigaom.nav.val = 0;

		// initialize the sidepanel toggle behaviors
		for ( var panel in gigaom.nav.panels ) {
			gigaom.nav.init_sidepanel( panel );
		}//end for

		$(document).on( 'click tap MSPointerDown', '.go-device-full .nav-search, .go-device-tablet.show-search .nav-search', function( e ) {
			e.preventDefault();
			gigaom.nav.$search_field.focus();
		});

		$(document).on( 'click tap MSPointerDown', '.go-device-phone .nav-search, .go-device-tablet .nav-search', function( e ) {
			e.preventDefault();
			gigaom.nav.search_show();
		});

		$(document).on( 'blur', '.go-device-phone .nav-search input, .go-device-tablet .nav-search input', function( e ) {
			gigaom.nav.search_hide();
		});

		$(document).on('click', '.sidepanel .expandable > h5', function(e) {
			e.preventDefault();
			gigaom.nav.expandable(this);
		});

		// hover intent on the icons in the full nav
		$(document).on('mouseenter', '.icons.right', function() {
			if ( true !== $(this).data('prevent-hover') ) {
				$(this).addClass('hovering');
			}//end else
		});

		$(document).on('mouseleave', '.icons.right', function() {
			$(this).removeClass('hovering');
		});

		$(document).on('mouseenter', '.icons.right > li', function() {
			$(this).doTimeout( 250, function() {
				if ( ! this.hasClass('nav-hover') ) {
					if ( true !== $(this).data('prevent-hover') ) {
						this.addClass('nav-hover');

						var $controller = this.children('a');

						// if we are in full-width mode and this controller has a panel,
						// publish a control open event on hover
						if ( gigaom.$html_body.hasClass('go-device-full') && $controller.data('panel') ) {
							amplify.publish( 'go-nav-control-open', $controller.data('panel').name );
						}//end if
					}//end if
				}//end if
			});
		});

		$(document).on('mouseleave', '.icons.right > li', function() {
			$(this).doTimeout( 300, function() {
				if ( ! this.hasClass('nav-tap') ) {
					this.removeClass('nav-hover');
					this.data('prevent-hover', false);
				}//end if
			});
		});

		$(document).on('tap MSPointerDown', '.icons.right > li > a', function( e ) {
			e.preventDefault();
			e.stopPropagation();

			var $container = $(this).closest('li'); 

			if ( $container.hasClass('nav-tap') ) {
				$container.removeClass('nav-hover nav-tap');
			} else {
				$container.addClass('nav-hover nav-tap');
				$container.closest('.icons').find('li').not( $container ).removeClass('nav-tap nav-hover');
			}//end else

			$container.data('prevent-hover', true);
		});

		// make sure the icons are still clickable
		$(document).on('click tap', '.icons.right > li div a', function( e ) {
			e.stopPropagation();
		});
		
		// we only want to toggle the sidepanels when the width changes...not the height
		gigaom.nav.window_width = $( window ).width();

		$(window).resize( 'resize', function() {
			var window_width = $( window ).width();

			if ( ! gigaom.nav.$sidepanels.find('input:focus').length && window_width != gigaom.nav.window_width ) {
				gigaom.nav.toggle_reset();
				gigaom.$html_body.removeClass( 'show-search' );

				// the width has changed. Let's track the new width
				gigaom.nav.window_width = window_width;
			}
		});

		amplify.publish( 'go-nav-init' );
	};

	gigaom.nav.init_sidepanel = function( panel ) {
		$( gigaom.nav.panels[ panel ].control ).data( 'panel', gigaom.nav.panels[ panel ] );

		$(document).on('click', gigaom.nav.panels[ panel ].control, function(e) {
			if ( ! $( this ).data( 'panel' ) ) {
				return;
			}//end if

			e.preventDefault();
			gigaom.nav.toggle( $(this).data('panel').name, $(this).data('panel').direction );
		});
	};

	gigaom.nav.search_show = function() {
		if ( ! gigaom.$html_body.hasClass( 'show-search' ) ) {
			gigaom.$html_body.addClass( 'show-search' );
			gigaom.nav.$search_field.focus();
		}//end else
	};

	gigaom.nav.search_hide = function() {
		var value = $.trim( gigaom.nav.$search_field.val() );

		if ( '' === value ) {
			gigaom.$html_body.removeClass( 'show-search' );
		}//end if
	};

	gigaom.nav.toggle = function( panel, direction ) {
		// direction should only ever contain 'left' or 'right'
		gigaom.nav.val = gigaom.$wrapper.css( direction );
		gigaom.nav.direction = direction;
		gigaom.nav.$sidepanel = $('.sidepanel.' + panel);
		gigaom.$html_body.addClass( 'show-sidepanel' );
		gigaom.$html_body.addClass( 'show-sidepanel-' + panel );
		var max_width = null;
		var max_height = null;

		if ( "auto" === gigaom.nav.val || "0px" === gigaom.nav.val || ! gigaom.nav.val ) {
			gigaom.nav.swipe_init();

			gigaom.nav.val = 270;
			max_width = gigaom.$html_body.width();
			max_height = gigaom.nav.$sidepanel.height();

			if ( $(window).height() > max_height ) {
				max_height = $(window).height();
			}//end if

			// no horizontal scrollbar while the menu is out
			gigaom.$html_body.addClass('no-overflow');
			gigaom.$html_body.height( max_height );
			gigaom.nav.$sidepanel.addClass('exposed');

			gigaom.nav.animate_sidepanel( gigaom.nav.direction, gigaom.nav.val, function() {
				gigaom.$html_body.width( max_width );	
				
				gigaom.$wrapper.css( 'overflow', 'hidden' );
				gigaom.$wrapper.css( 'overflow-y', 'hidden' );
				gigaom.$wrapper.height( max_height );
				gigaom.$inner_wrapper.width( gigaom.$inner_wrapper.width() );
				gigaom.$inner_wrapper.css( gigaom.nav.direction, 0);
				gigaom.$inner_wrapper.css('position', 'absolute');
				gigaom.$nav.width( gigaom.$nav.width() );
				gigaom.$nav.height( gigaom.$nav.height() );
				gigaom.$wrapper.css('position', 'absolute');
				gigaom.$wrapper.width( $(window).width() - gigaom.nav.$sidepanel.width() );

				// Sometimes timing is off.  We don't know how.  Whe dhon't khnow where.  But it is happening
				// and the next if block MAKES SURE that the sidepanel is visible at the end of the opening
				// animation.
				if ( ! gigaom.nav.$sidepanel.is('.exposed') ) {
					gigaom.nav.$sidepanel.addClass('exposed');
				}

				amplify.publish( 'go-nav-control-open', panel );
			});
		} else {
			gigaom.nav.toggle_reset();
		}// end else
	};

	gigaom.nav.animate_sidepanel = function( direction, val, callback ) {
		var changed = {};
		changed[ direction ] = val;

		gigaom.$wrapper.animate( changed, 300, callback );
	};

	/**
	 * Resets the pagebody and viewport (untested)
	 */
	gigaom.nav.toggle_reset = function() {
		gigaom.nav.val = 0;

		gigaom.$wrapper.css('position', 'relative');
		gigaom.$wrapper.css('width', 'auto');
		gigaom.$inner_wrapper.removeAttr('style');
		gigaom.$nav.removeAttr('style');

		// animating on close results in some f'ed up stuff
		// So...just reset everything
		gigaom.$html_body.removeClass('no-overflow');

		for ( var panel in gigaom.nav.panels ) {
			gigaom.$html_body.removeClass( 'show-sidepanel-' + panel );
		}//end for

		gigaom.$html_body.removeClass( 'show-sidepanel' );

		gigaom.$html_body.removeAttr('style');
		gigaom.nav.$sidepanels.removeClass('exposed');
		gigaom.$wrapper.removeAttr('style');
		gigaom.nav.animating = false;
	};

	/**
	 * builds the expandable/collapsible elements in the sidepanel
	 */
	gigaom.nav.expandable = function (el) {
		var $p = $(el).parent();
		var $p2 = $p.parent();
		var expandable = $p.children('.content').first();

		if ( $p.is( '.active ') ) {
			expandable.hide();
			$p.removeClass('active');
		} // end if
		else {
			jQuery( '.content', $p2 ).not( expandable ).hide().parent('li').removeClass('active');
			expandable.show(0, function () {
				expandable.parent('li').addClass('active');
			});
		}// end else
	};

	/**
	 * setup events for swipe action when sidepanel is exposed
	 */
	gigaom.nav.swipe_init = function() {
		gigaom.$html_body.on( 'touchstart.nav-swipe', gigaom.nav.swipe_start );
		gigaom.$html_body.on( 'touchmove.nav-swipe', gigaom.nav.swipe_move );
		gigaom.$html_body.on( 'touchend.nav-swipe', gigaom.nav.swipe_end );
		gigaom.$html_body.on( 'touchcancel.nav-swipe', gigaom.nav.swipe_cancel );
	};

	/**
	 * Swipe is starting.  Capture starting x coords
	 */
	gigaom.nav.swipe_start =  function( e ) {
		gigaom.nav.swipe_x_start = e.originalEvent.pageX;
		gigaom.nav.swipe_x_latest = e.originalEvent.pageX;
	};

	/**
	 * Capture the current x coords when move event fires
	 */
	gigaom.nav.swipe_move = function( e ) {
		gigaom.nav.swipe_x_latest = e.originalEvent.pageX;
	};

	/**
	 * Swiping has ended.  Determine if we need to do anything.
	 */
	gigaom.nav.swipe_end = function(e) {
		var distance = gigaom.nav.swipe_x_start - gigaom.nav.swipe_x_latest;

		if (
				 ( distance > 100 && 'left' === gigaom.nav.direction )
			|| ( distance < -100 && 'right' === gigaom.nav.direction )
		) {
			gigaom.nav.toggle_reset();
			gigaom.nav.swipe_cancel( e );
		}
	};

	/**
	 * Cancel the swipe.  Unbind the events
	 */
	gigaom.nav.swipe_cancel = function( ) {
		gigaom.$html_body.off( 'touchstart.nav-swipe' );
		gigaom.$html_body.off( 'touchmove.nav-swipe' );
		gigaom.$html_body.off( 'touchend.nav-swipe' );
		gigaom.$html_body.off( 'touchcancel.nav-swipe' );
	};
})( jQuery );
;
gigaom.resize = {};

( function( $ ) {
	"use strict";

	gigaom.resize.$reset  = null;
	gigaom.resize.prefix  = 'go-device-';
	gigaom.resize.states  = [ 'full', 'phone', 'tablet' ];
	gigaom.resize.initial = true;

	/**
	 * clear resize classes
	 */
	gigaom.resize.clear_classes = function() {
		for( var i in gigaom.resize.states ) {
			gigaom.$html_body.removeClass( gigaom.resize.prefix + gigaom.resize.states[ i ] );
		}//end for
	};//end gigaom.resize.clear_classes

	/**
	 * Execute a resize action
	 */
	gigaom.resize.execute = function() {
		//Changing because, scrollbars...
		var page_width = Math.max( $(window).width(), window.innerWidth);

		if ( page_width >= 960 ) {
			gigaom.resize.set( 'full' );
		} else if ( page_width <= 640 ) {
			gigaom.resize.set( 'phone' );
		} else if ( page_width < 960 ) {
			gigaom.resize.set( 'tablet' );
		}//end elseif

		amplify.publish( 'go-resize-execute' );
		$( document ).trigger( 'go-resize-execute' );

		if ( gigaom.resize.timer ) {
			clearTimeout( gigaom.resize.timer );
		}//end if
	};//end gigaom.resize.execute

	/**
	 * call the child object init methods
	 */
	gigaom.resize.init = function() {
		gigaom.resize.dynamic.init();

		amplify.publish( 'go-resize-init' );
		$( document ).trigger( 'go-resize-init' );

		// only bind to resize if we're not in IE
		if ( gigaom.is_old_ie ) {
			// if we are on IE versions less than 9, always report
			// that we're on full width
			gigaom.resize.set( 'full' );
		} else {
			// when the window has resized, notify the core library that it may
			// need to do something.
			$( window ).resize( gigaom.resize.prep );

			// execute the first resize to force the proper layout on page load
			gigaom.resize.execute();
		}//end else
		
		if ( true === gigaom.resize.initial ) {
			amplify.publish( 'go-resize-initial' );
			$( document ).trigger( 'go-resize-initial' );
			gigaom.resize.initial = false;
		}//end if
	};//end gigaom.resize.init

	/**
	 * Get ready to do a resize action, which fires off after 100 miliseconds
	 * to avoid continuous calling.
	 *
	 * This method is called using $.proxy so the context is the gigaom object
	 */
	gigaom.resize.prep = function() {
		clearTimeout( gigaom.resize.timer );
		gigaom.resize.timer = setTimeout( gigaom.resize.execute, 100 );
	};//end gigaom.resize.prep

	/**
	 * Returns DOM elements to their original position before resize
	 */
	gigaom.resize.reset = function( states ) {
		gigaom.resize.clear_classes();
		amplify.publish( 'go-resize-reset', states );
		$( document ).trigger( 'go-resize-reset', states );
	};//end gigaom.resize.reset

	/**
	 * Determines if the from state has a special reset function.  If so,
	 * that reset method is executed.
	 *
	 * NOTE: this function is executed in the context of its calling subscription
	 *
	 * @param states Object Contains to and from states as a reset occurs
	 */
	gigaom.resize.reset_handler = function( states ) {
		if ( this.reset[ states.from ] !== undefined ) {
			this.reset[ states.from ]();
		}//end else
	};//end gigaom.resize.reset_handler

	/**
	 * does the work to set the resize state
	 */
	gigaom.resize.set = function( state ) {
		// don't bother attempting to set the resize state if we're
		// already at that state
		if ( ! gigaom.$html_body.hasClass( gigaom.resize.prefix + state ) ) {
			// We're changing states.  Let's get the current state
			var states = {
				from: gigaom.resize.state().replace( gigaom.resize.prefix, '' ),
				to: state
			};

			// clear the state
			gigaom.resize.reset( states );

			// set the new state
			gigaom.$html_body.addClass( gigaom.resize.prefix + states.to );

			amplify.publish( 'go-resize', states );
			$( document ).trigger( 'go-resize', states );

			// publish the change in resize state
			amplify.publish( 'go-resize-' + state, states );
			$( document ).trigger( 'go-resize-' + state, states );
		}//end if
	};//gigaom.resize.set

	/**
	 * get the current state of the page
	 */
	gigaom.resize.state = function() {
		var state = null;

		for( var i in gigaom.resize.states ) {
			state = $.trim( gigaom.resize.prefix + gigaom.resize.states[ i ] );

			if ( gigaom.$html_body.hasClass( state ) ) {
				return $.trim( state );
			}//end if
		}//end for

		return gigaom.resize.prefix + 'phone';
	};//end gigaom.resize.state

	/**
	 * Stores the currently pending resize timer
	 */
	gigaom.resize.timer = null;
})( jQuery );
;
gigaom.resize.dynamic = {};

( function( $ ) {
	'use strict';

	gigaom.resize.dynamic.widgets = {};
	gigaom.resize.dynamic.injection_areas = {};

	/**
	 * position elements for the desktop
	 */
	gigaom.resize.dynamic.full = function() {
		gigaom.resize.dynamic.device( 'full' );
	};//end gigaom.resize.dynamic.full

	/**
	 * initializes the dynamic resize stuff
	 */
	gigaom.resize.dynamic.init = function() {
		var injection_area = {};
		var widget = {};

		for ( var device in go_responsive ) {
			for ( var injection in go_responsive[ device ] ) {
				if ( ! go_responsive[ device ][ injection ].widget ) {
					continue;
				}//end if

				if ( ! gigaom.resize.dynamic.injection_areas[ injection ] ) {
					injection_area          = {};
					injection_area.el_class = injection;
					injection_area.$el      = $( document.getElementById( injection_area.el_class ) );
				} else {
					injection_area = gigaom.resize.dynamic.injection_areas[ injection ];
				}//end else

				widget = {};
				widget.el_class       = go_responsive[ device ][ injection ].widget;
				widget.$el            = $( '.' + widget.el_class );
				if ( ! widget.$el.length )
				{
					widget.$el = $( document.getElementById(  widget.el_class ) );
				}//end if
				widget.bookmark_class = widget.el_class + '_bookmark';

				// if both the injection area and the widget area exist on the page,
				// save those areas off for 
				if ( injection_area.$el.length === 0 && widget.$el.length === 0 ) {
					continue;
				}//end if

				gigaom.resize.dynamic.injection_areas[ injection_area.el_class ] = gigaom.resize.dynamic.injection_areas[ injection_area.el_class ] || injection_area;
				gigaom.resize.dynamic.widgets[ widget.el_class ]       = gigaom.resize.dynamic.widgets[ widget.el_class ] || widget;
			}//end for
		}//end for

		amplify.subscribe( 'go-resize-full', gigaom.resize.dynamic.full );
		amplify.subscribe( 'go-resize-phone', gigaom.resize.dynamic.phone );
		amplify.subscribe( 'go-resize-reset', gigaom.resize.dynamic, gigaom.resize.reset_handler );
		amplify.subscribe( 'go-resize-tablet', gigaom.resize.dynamic.tablet );
	};

	/**
	 * fires off device actions on resize
	 */
	gigaom.resize.dynamic.device = function( device ) {
		var the_class = '';
		var injection_area = null;
		var widget = null;

		// we don't need to do anything with injection widgets on single pages
		if ( $( 'body.single' ).length && $( 'body.property-gigaom' ).length ) {
			return;
		}//end if

		for ( var injection in go_responsive[ device ] ) {
			the_class = go_responsive[ device ][ injection ].widget;

			if ( gigaom.resize.dynamic.injection_areas[ injection ] && gigaom.resize.dynamic.widgets[ the_class ] ) {
				injection_area = gigaom.resize.dynamic.injection_areas[ injection ];
				widget = gigaom.resize.dynamic.widgets[ the_class ];

				var inject_classes = widget.$el.data('remove-on-inject-classes') || '';

				widget.$el.after( '<div class="bookmarked-widget ' + widget.bookmark_class + ' ' + inject_classes + '"></div>' );
				widget.$el.prependTo( injection_area.$el );

				var remove_classes = inject_classes.split( ' ' );
				var add_classes = go_responsive[ device ][ injection ]['class'].split( ' ' );
				
				for ( var remove in remove_classes ) {
					if ( -1 === $.inArray( remove_classes[ remove ], add_classes ) ) {
						widget.$el.removeClass( remove_classes[ remove ] );
					}//end if
				}//end for

				injection_area.$el.data( 'responsive_classes', add_classes.join( ' ' ) );
				injection_area.$el.addClass( add_classes.join( ' ' ) );
			}//end if
		}//end for
	};

	/**
	 * position elements for the phone
	 */
	gigaom.resize.dynamic.phone = function() {
		gigaom.resize.dynamic.device( 'phone' );
	};//end gigaom.resize.dynamic.phone

	/**
	 * reset object for the waterfall
	 */
	gigaom.resize.dynamic.reset = {};

	gigaom.resize.dynamic.reset.device = function( device ) {
		var the_class = '';
		var injection_area = null;
		var widget = null;
		var $bookmark = null;

		for ( var injection in go_responsive[ device ] ) {
			the_class = go_responsive[ device ][ injection ].widget;

			if ( gigaom.resize.dynamic.injection_areas[ injection ] && gigaom.resize.dynamic.widgets[ the_class ] ) {
				injection_area = gigaom.resize.dynamic.injection_areas[ injection ];
				widget = gigaom.resize.dynamic.widgets[ the_class ];

				$bookmark = $( '.' + widget.bookmark_class );

				widget.$el.insertBefore( $bookmark );
				injection_area.$el.html('');

				var inject_classes = widget.$el.data('remove-on-inject-classes') || '';
				var add_classes = inject_classes.split( ' ' );
				
				for ( var add in add_classes ) {
					if ( ! widget.$el.hasClass( add_classes[ add ] ) ) {
						widget.$el.addClass( add_classes[ add ] );
					}//end if
				}//end for

				injection_area.$el.removeClass( injection_area.$el.data( 'responsive_classes' ) );
				injection_area.$el.data( 'responsive_classes', '' );
				$bookmark.remove();
			}//end if
		}//end for
	};

	/**
	 * Reset from a full sized page
	 */
	gigaom.resize.dynamic.reset.full = function() {
		gigaom.resize.dynamic.reset.device( 'full' );
	};//end gigaom.resize.dynamic.reset.full

	/**
	 * Reset from a phone sized page
	 */
	gigaom.resize.dynamic.reset.phone = function() {
		gigaom.resize.dynamic.reset.device( 'phone' );
	};//end gigaom.resize.dynamic.reset.phone

	/**
	 * Reset from a tablet sized page
	 */
	gigaom.resize.dynamic.reset.tablet = function() {
		gigaom.resize.dynamic.reset.device( 'tablet' );
	};//end gigaom.resize.dynamic.reset.tablet

	/**
	 * position elements for the tablet
	 */
	gigaom.resize.dynamic.tablet = function() {
		gigaom.resize.dynamic.device( 'tablet' );
	};//end gigaom.resize.dynamic.tablet
})( jQuery );
;
gigaom.text_scale = {};

( function( $ ) {
	"use strict";

	gigaom.text_scale.size_huge   = 'text-size-huge';
	gigaom.text_scale.size_large  = 'text-size-large';
	gigaom.text_scale.size_normal = 'text-size-normal';

	/**
	 * initializes the text scale element on story pages
	 */
	gigaom.text_scale.init = function() {
		$(document).on( 'click', '.text-scale .larger a', function( e ) {
			e.preventDefault();
			gigaom.text_scale.increase();
		});

		$(document).on( 'click', '.text-scale .smaller a', function( e ) {
			e.preventDefault();
			gigaom.text_scale.decrease();
		});

		gigaom.$html_body.addClass( gigaom.text_scale.size_normal );
	};

	/**
	 * assigns an appropriate class to the body based on the number of times
	 * that the decrease action has been clicked in the text scale element
	 */
	gigaom.text_scale.decrease = function() {
		if ( gigaom.$html_body.hasClass( gigaom.text_scale.size_normal ) ) {
			return;
		}//end if

		if ( gigaom.$html_body.hasClass( gigaom.text_scale.size_large ) ) {
			gigaom.$html_body.addClass( gigaom.text_scale.size_normal ).removeClass( gigaom.text_scale.size_large );
			return;
		}//end if

		gigaom.$html_body.addClass( gigaom.text_scale.size_large ).removeClass( gigaom.text_scale.size_huge );
	};

	/**
	 * assigns an appropriate class to the body based on the number of times
	 * that the increase action has been clicked in the text scale element
	 */
	gigaom.text_scale.increase = function() {
		if ( gigaom.$html_body.hasClass( gigaom.text_scale.size_huge ) ) {
			return;
		}//end if

		if ( gigaom.$html_body.hasClass( gigaom.text_scale.size_large ) ) {
			gigaom.$html_body.addClass( gigaom.text_scale.size_huge ).removeClass( gigaom.text_scale.size_large );
			return;
		}//end if

		gigaom.$html_body.addClass( gigaom.text_scale.size_large ).removeClass( gigaom.text_scale.size_normal );
	};
})( jQuery );
;
gigaom.single = {};

( function( $ ) {
	'use strict';

	/**
	 * initializes the single page stuff
	 */
	gigaom.single.init = function() {
		if ( ! gigaom.$html_body.hasClass('single') ) {
			return;
		}//end if

		gigaom.single.$subhead = $('.sub-head');
		gigaom.single.$thumbnail = $('.thumbnail-container');
		gigaom.single.$thumbnail_inject = $('.inject-thumb');
		gigaom.single.$comments = $( document.getElementById( 'comments' ) );
		gigaom.single.$comment_form_top = $( document.getElementById( 'comment-form-top' ) );
		gigaom.single.$comment_form_bot = $( document.getElementById( 'comment-form-bottom' ) );
		gigaom.single.$comment_list_inner = $( document.getElementById( 'comment-list-inner' ) );
		gigaom.single.pause_comment_waypoints = false;

		$(document).on( 'change', '#go-page-select', gigaom.single.nav_change );

		amplify.subscribe( 'go-resize', function() {
			gigaom.single.adjust_cta_ad();
		});

		$(window).resize( $.throttle( 100, gigaom.single.adjust_cta_ad ) );

		$(window).resize( $.throttle( 100, gigaom.single.add_ellipses_to_some_headings ) );

		if ( 'undefined' !== typeof gigaom_resize_post_head ) {
			// make sure we attempt to resize the featured image any time we resize
			// NOTE: that function comes from js/lib/early.js
			$(window).resize( $.throttle( 100, gigaom_resize_post_head ) );

			amplify.subscribe( 'go-resize', function() {
				gigaom_resize_post_head();
			});
		}//end if

		$( document ).on( 'click touchstart', '.social .more a', function( e ) {
			e.preventDefault();

			$( this ).closest( '.social' ).addClass( 'show-more' );
		});

		$( document ).on( 'scroll', function() {
			$( '.social.show-more' ).removeClass( 'show-more' );
		});

		$( document ).on( 'go-contentwidgets-complete', gigaom.single.relocate_ctas );
		$( document ).on( 'go-local-bsocial-auth-processed', gigaom.single.maybe_remove_newsletter_cta );

		gigaom.single.add_ellipses_to_some_headings();
		gigaom.single.wrap_breakout_images();
		gigaom.single.colorbox_init();
		gigaom.single.comment_waypoint();
		gigaom.single.legacy_twitter();
		gigaom.single.comment_ads();
		gigaom.single.init_sticky_social();
		gigaom.single.init_responsive_tables();
	};//end gigaom.single.init

	/**
	 * Wrap aligncenter size-full images with an element so they can break beyond the bounds of the page
	 */
	gigaom.single.wrap_breakout_images = function() {
		// first, let's wrap size-full images with captions
		$( '.wp-caption.aligncenter' ).each( function() {
			var $el = $( this );
			var $img = $el.find( 'img' );

			if ( ! $img.hasClass( 'size-full' ) ) {
				return;
			}//end if

			$el.wrap( '<div class="breakout-wrapper"/>' );
		});

		// for size-full images that don't have captions, we need to wrap them too
		$( 'img.aligncenter.size-full' ).each( function() {
			var $el = $( this );
			if ( $el.closest( '.wp-caption' ).length ) {
				return;
			}//end if

			if ( $el.closest( 'picture' ).length ) {
				$el.closest( 'picture' ).wrap( '<span class="breakout-wrapper"/>' );
				return;
			}//end if

			$el.wrap( '<span class="breakout-wrapper"/>' );
		});
	};

	gigaom.single.add_ellipses_to_some_headings = function() {
		var number_of_lines_to_show = 3;
		var $links;
		var line_height;

		var selectors = [
			'.widget-go-featured li > a',
			'.go-related-container .related-post > a'
		];

		for ( var i in selectors ) {
			$links = $( selectors[ i ] );

			if ( ! $links.length ) {
				continue;
			}//end if

			// determine the first link's line height
			line_height = $.trim( $links.eq( 0 ).css( 'line-height' ).replace( 'px', '' ) );
			line_height = Math.ceil( parseFloat( line_height ) );

			$links.dotdotdot({
				height: line_height * number_of_lines_to_show,
				tolerance: 5
			});
		}//end for
	};

	/**
	 * adds comment waypoints to move the comment box around
	 * based on where the user is on the page
	 */
	gigaom.single.comment_waypoint = function() {
		var viewport_height = $.waypoints('viewportHeight');
		var comments_height = gigaom.single.$comment_list_inner.find( '.comments-list').height();

		gigaom.single.$comment_form_top.waypoint( function( e, direction ) {
			if ( gigaom.single.pause_comment_waypoints ) {
				return;
			}//end if

			if ( 'up' !== direction ) {
				return;
			}//end if

			if ( 0 !== $(this).children( '#commentform' ).length ) {
				return;
			}//end if

			if ( viewport_height > comments_height ) {
				return;
			}//end if

			$( document.getElementById( 'commentform-bookmark' ) ).remove();
			gigaom.single.$comment_form_bot.children().prependTo( $(this) );
		}, {
			offset: function() {
				return -1 *  gigaom.single.$comment_form_top.height();
			}
		});

		gigaom.single.$comment_form_bot.waypoint( function( e, direction ) {
			if ( gigaom.single.pause_comment_waypoints ) {
				return;
			}//end if

			if ( 'down' !== direction ) {
				return;
			}//end if

			if ( $(this).html() && $(this).html().trim() ) {
				return;
			}//end if

			if ( viewport_height > comments_height ) {
				return;
			}//end if

			var $bookmark = $( '<div id="commentform-bookmark"/>' );
			$bookmark.css({
				height: gigaom.single.$comment_form_top.children( '#commentform' ).outerHeight()
			});
			gigaom.single.$comment_form_top.children( '#commentform' ).appendTo( $(this) );
			gigaom.single.$comment_form_top.append( $bookmark );
		}, {
			offset: function() {
				return $.waypoints('viewportHeight') - $(this).outerHeight();
			}
		});
	};

	/**
	 * initialize colorbox behaviors
	 */
	gigaom.single.colorbox_init = function() {
		var $images = gigaom.$body.find('article.post .body').find('img');
		var $image_anchors = $images.closest('a');

		$image_anchors.attr( 'rel', 'gallery');
		$image_anchors.each( function() {
			var href = $(this).attr('href') || '';

			if ( ! href.match( /\.(jpg|jpeg|gif|png)(\?.*)?$/i ) ) {
				return;
			}//end if

			var $caption_container = $(this).closest('.wp-caption');
			var caption = '';

			if ( $caption_container.length > 0 ) {
				caption = $caption_container.find('.wp-caption-text').html();
			}//end if

			$(document).on('mouseover', '.cboxPhoto', function() {
				$(this).closest('#cboxContent').addClass('cbox-hover');
			});

			$(document).on('mouseout cbox_closed cbox_complete', '.cboxPhoto', function() {
				$(this).closest('#cboxContent').removeClass('cbox-hover');
			});

			$(this).colorbox({
				title: caption,
				maxHeight: '90%',
				maxWidth: '90%',
				onComplete: function() {
					$( document.getElementById( 'colorbox' ) ).width( $( document.getElementById( 'cboxWrapper' ) ).width() ).height( $( document.getElementById( 'cboxWrapper' ) ).height() );
				}
			});
		});
	};

	/**
	 * initialize the legacy twitter share link for posts that have an old twitter share link
	 * in place.
	 */
	gigaom.single.legacy_twitter = function() {
		$('.twitter-share-button').each( function() {
			if ( $(this).find('.icon-twitter').length > 0 ) {
				return;
			}//end if

			var url = 'https://twitter.com/intent/tweet';
			url += '?text=' + escape( $(this).data('text') );
			url += '&url=' + $(this).data('url');

			$(this).attr('href', url).addClass('tweet-this').text('tweet this').prepend('<i class="goicon icon-twitter"></i> ');
		});
	};

	/**
	 * navigate to a new page on change of the nav dropdown
	 */
	gigaom.single.nav_change = function() {
		window.location = $(this).val();
	};

	/**
	 * shifts the CTA ad down so it aligns with the newsletter box
	 */
	gigaom.single.adjust_cta_ad = function() {
		var $newsletter = $('#go-newsletter-email:visible,.cta-section .subscribed:visible');

		if ( ! $newsletter.length ) {
			return;
		}//end if

		var $ad = $('.go-bsocial-cta').next();

		var newsletter_bottom_edge = $newsletter.offset().top + $newsletter.height();
		var ad_bottom_edge = $ad.offset().top + $ad.height();

		var shift = newsletter_bottom_edge - ad_bottom_edge - 3;

		if ( shift < 0 ) {
			shift = 0;
		}//end if

		$ad.css( 'margin-top', shift );
	};

	gigaom.single.comment_ads = function() {
		var $comments = gigaom.single.$comment_list_inner.find( '.comment .div-comment' );

		if ( $comments.length > 4 ) {
			var $comment_ad1 = $( document.getElementById( 'ad-comment1' ) );
			$comments.eq( 4 ).after( $comment_ad1.closest( '.widget-go-ads' ) );
			$comment_ad1.closest( '#ad-comment1-container' ).show();
		}

		if ( $comments.length > 29 ) {
			var $comment_ad2 = $( document.getElementById( 'ad-comment2' ) );
			$comments.eq( 19 ).after( $comment_ad2.closest( '.widget-go-ads' ) );
			$comment_ad2.closest( '#ad-comment1-container' ).show();
		}
	};

	/**
	 * Remove the newsletter widget if the user is subscribed
	 */
	gigaom.single.maybe_remove_newsletter_cta = function() {
		// if go_remote_identity isn't anywhere to be found, bail
		if ( 'undefined' === typeof go_remote_identity ) {
			return;
		}//end if

		// if identity hasn't been checked, bail.
		if ( false === go_remote_identity.identity_checked ) {
			return;
		}//end if

		var $newsletter = $( '.go-bsocial-cta' );

		if ( $newsletter.find( '.subscribed' ).is( ':visible' ) )
		{
			$newsletter.closest( '.go-thisorthat-widget' ).remove();
			$newsletter.remove();
		}//end if
	};

	/**
	 * Moves house CTAs into the right location after inserting into the content
	 */
	gigaom.single.relocate_ctas = function() {
		var $sidebar = $( document.getElementById( 'hidden-sidebar' ) );
		var $post_tags = $( '.post-page-tags:first' );
		var $thisorthat = $sidebar.find( '.go-thisorthat-widget' );

		// ***********************
		// First: support the configuration where the newsletter widget and autoE are configured in the thisorthat widget
		// ***********************
		if ( $thisorthat.length ) {
			// let's remove the div wrapper from the thisorthat widget
			$thisorthat = $thisorthat.children( 'div' );
			$thisorthat.unwrap();
			$thisorthat.find( '.injected-size-half' ).removeClass( 'injected-size-half' );

			// if thisorthat IS the bsocial cta, place it after the post_tags. If it isn't, place it after the bsocial cta
			if ( $thisorthat.is( '.go-bsocial-cta' ) ) {
				$post_tags.after( $thisorthat );
			} else {
				$post_tags.closest( '.main' ).find( '.go-bsocial-cta' ).after( $thisorthat );
			}//end else
		}//end if

		// ***********************
		// Next: support the configuration where the newsletter widget and autoE are individual widgets within the injection sidebar
		// ***********************
		var $autoe = $sidebar.find( '.go-event-navigation-relatedevent' );
		var $newsletter = $sidebar.find( '.go-bsocial-cta' );

		var classes_to_remove = 'layout-box-insert layout-box-insert-right layout-box-insert-left';

		if ( $autoe.length ) {
			$autoe.removeClass( classes_to_remove );
			$post_tags.after( $autoe );
		}//end if

		if ( $newsletter.length ) {
			$newsletter.removeClass( classes_to_remove );
			$post_tags.after( $newsletter );
		}//end if
	};

	/**
	 * initializes responsive tables
	 */
	gigaom.single.init_responsive_tables = function() {
		if (
			! gigaom.$html_body.hasClass( 'property-gigaom' )
			&& ! gigaom.$html_body.hasClass( 'property-research' )
		) {
			return;
		}//end if

		var $tables = $('.single .post, .single .page').find('table').not('.sidebar');

		$tables.addClass('responsive');
		$tables.wrap( '<div class="table-wrapper"/>' );
	};

	/**
	 * sets up the sticky social icons behaviors
	 */
	gigaom.single.init_sticky_social = function() {
		gigaom.single.$sticky_social = $( '.single-post .post-social:not(.above-featured)' );

		if ( ! gigaom.single.$sticky_social.length ) {
			return;
		}//end if

		gigaom.single.$sticky_social.waypoint( {
			offset: 0,
			handler: function( direction ) {
				if ( 'down' === direction ) {
					$( this ).addClass( 'sticky' );
				} else if ( 'up' === direction ) {
					$( this ).removeClass( 'sticky' );
				}
			}
		});

		$( document ).on( 'scroll', this.track_sticky_social );
	};

	/**
	 * handles the scroll event for the sticky social icons
	 */
	gigaom.single.track_sticky_social = function() {
		var scroll_top = $( window ).scrollTop();
		var $article = gigaom.single.$sticky_social.closest( 'article' );

		var foot_offset = gigaom.$foot.offset().top;
		var article_offset = $article.offset().top;
		var social_offset = gigaom.single.$sticky_social.offset().top;

		var article_height = $article.height();
		var social_height = gigaom.single.$sticky_social.find( 'ul' ).height();

		if (
			( social_offset + social_height >= ( foot_offset - 16 ) )
			&& ! gigaom.single.$sticky_social.hasClass( 'sticky-stop' )
		) {
			gigaom.single.$sticky_social.addClass( 'sticky-stop' );

			gigaom.single.$sticky_social.css({
				position: 'absolute',
				bottom: ( -1 * ( foot_offset - article_offset - article_height - social_height ) ) + 'px',
				top: 'auto'
			});
		}//end if
		else if ( scroll_top < social_offset )
		{
			gigaom.single.$sticky_social.removeClass( 'sticky-stop' );

			gigaom.single.$sticky_social.css({
				position: '',
				bottom: '',
				top: ''
			});
		} else if ( scroll_top > social_offset && ! gigaom.single.$sticky_social.is( 'sticky' ) ) {
			gigaom.single.$sticky_social.addClass( 'sticky' );
		}//end else
	};
} )( jQuery );
;
gigaom.gallery = {};

( function( $ ) {
	"use strict";

	gigaom.gallery.activated = false;

	gigaom.gallery.init = function() {
		gigaom.gallery.$gallery = $('.gallery');
		gigaom.gallery.$nav = gigaom.gallery.$gallery.find('.gallery-nav');
		gigaom.gallery.$image_list = gigaom.gallery.$gallery.find('.image-list');

		amplify.subscribe( 'go-resize', gigaom.gallery.resize );

		gigaom.gallery.resize();
	};

	/**
	 * activates the gigaom gallery animation
	 */
	gigaom.gallery.activate = function() {
		var thumb_width = false;

		gigaom.gallery.$image_list.each( function() {
			var gallery_id = $( this ).closest( '.gallery' ).data( 'gallery-id' );

			$( this ).cycle({
				timeout: 5000,
				speed: 500,
				easing: 'easeOutExpo',
				before: function( currSlideElement, nextSlideElement, options, forwardFlag ) {
					var slide_number = $( nextSlideElement ).prevAll().length;
					var $current_gallery = $( currSlideElement ).closest( '.gallery' );
					var $current_list = $current_gallery.find( '.image-list' );
					var $current_nav = $current_gallery.find('.gallery-nav');

					$current_list.find('li').eq( slide_number ).find('.image-info .count').text( ( slide_number + 1 ) + ' / ' + options.slideCount );
					$current_list.find('li').eq( slide_number ).find('.image-info .title').text( $.trim( go_gallery_data[ gallery_id ][ slide_number ].title ) );

					// Establish our thumbnail total width
					if ( ! thumb_width ) {
						var $thumb = $current_nav.find('a').eq(0);

						if ( $thumb.length > 0 ) {
							thumb_width = parseInt( $thumb.outerWidth(), 10 )+ parseInt( $thumb.css('margin-right'), 10 ) + parseInt( $thumb.css('margin-left'), 10 );
						}//end if
					}//end if

					// Move the bottom thumbnails appropriately
					var offset = $current_nav.find('a').eq( slide_number ).position();

					if ( ! offset ) {
						return;
					}//end if

					var total_items     = $current_list.children().length;
					var total_width     = total_items * thumb_width;
					var parent_width    = $current_gallery.find( '.gallery-nav-inner' ).width();
					var items_per_width = parent_width / thumb_width;
					var left            = offset.left - ( items_per_width / 2 * thumb_width );
					var max_left        = - ( parent_width - total_width );

					// Set a maximum so that we stop moving once we hit the last thumb
					if ( left > max_left ) {
						left = max_left;
					}//end if

					if ( left > 0 && total_width > parent_width ) {
						$current_nav.animate( {left: -left}, 150, 'easeInOutExpo');
					}//end if
					else {
						if ( left < 0 ) {
							$current_nav.animate( {left: 0}, 150, 'easeInOutExpo');
						}//end if
					}//end else
				},
				pager: '#gallery-' + gallery_id + ' .gallery-nav',
				pagerAnchorBuilder: function( idx, slide ) {
					var current_gallery_id = $( slide ).closest( '.gallery' ).data( 'gallery-id' );

					return '<a href="#' + idx + '" class="image"><img src="' + go_gallery_data[ current_gallery_id ][ idx ].thumbnail + '" width="48" height="48"/></a>';
				},
				next: '#gallery-' + gallery_id + ' .gallery-next',
				prev: '#gallery-' + gallery_id + ' .gallery-prev'
			});
		});

		amplify.publish('go-gallery-init');
	};

	gigaom.gallery.resize = function( states ) {
		if ( gigaom.$html_body.is('.go-device-phone') ) {
			gigaom.gallery.activated = false;
			gigaom.gallery.$image_list.cycle('destroy');
			gigaom.gallery.$image_list.find('li').attr( 'style', '' );
			gigaom.gallery.$image_list.attr( 'style', '' );
		} else if ( ! gigaom.gallery.activated ) {
			gigaom.gallery.activated = true;
			gigaom.gallery.activate();

			var width = gigaom.$body.width();

			gigaom.gallery.$image_list.width( width );
			gigaom.gallery.$image_list.find('li').width( width );
		}//end else
	};
} )( jQuery );
;
gigaom.waterfall = {};

( function( $ ) {
	'use strict';

	/**
	 * Initialization of waterfall
	 */
	gigaom.waterfall.init = function() {
		if ( ! gigaom.$html_body.hasClass( 'waterfall' ) ) {
			return;
		}

		gigaom.waterfall.$daybreak = $('.daybreak');
		gigaom.waterfall.$wijax = $('.widget_postloop.go-wijax-aware-default-excerpt');

		gigaom.waterfall.add_waypoints();

		$( window ).on( 'resize', $.throttle( 100, gigaom.waterfall.relocate_ads ) );
		gigaom.waterfall.relocate_ads();
		amplify.subscribe( 'go-resize', function() {
			gigaom.waterfall.relocate_ads();
		});

		if ( 'undefined' !== typeof gigaom_resize_featured ) {
			$( window ).on( 'resize', $.throttle( 100, gigaom_resize_featured ) );
			amplify.subscribe( 'go-resize', function() {
				gigaom_resize_featured();
			});

			gigaom_resize_featured();
		}//end if
	};

	gigaom.waterfall.relocate_ads = function() {
		if ( $( '.widget-go-featured .featured-container' ).length > 1 ) {
			return;
		}//end if

		var window_width = $( window ).width();

		// we need to find them fresh every time
		var $ads = $( '.go-ad' );

		var $first_ad = $ads.eq( 0 );
		var $third_ad = $ads.eq( 2 );
		var $first_ad_wrapper = $first_ad.closest( '.widget-go-ads' );
		var $third_ad_wrapper = $third_ad.closest( '.widget-go-ads' );

		if ( window_width < 960 ) {
			if ( $first_ad.is( '.ad-300x600' ) ) {
				return;
			}//end if
		} else {
			if ( $first_ad.is( '.ad-300x250' ) ) {
				return;
			}//end if
		}//end else

		$first_ad_wrapper.append( $third_ad );
		$third_ad_wrapper.append( $first_ad );

		// if googletag doesn't exist, go-ads hasn't loaded and we don't need to worry about refreshing ads because
		// they haven't been loaded in the first place
		if ( 'undefined' !== typeof googletag && 'undefined' !== typeof googletag.pubads ) {
			googletag.pubads().refresh();
		}//end if
	};

	/**
	 * Adds waypoints for wijax excerpts
	 */
	// @TODO remove this function
	gigaom.waterfall.add_waypoints = function() {
		$.waypoints.settings.scrollThrottle = 500;

		// @TODO remove everything after this if statement in this function when the waterfall redesign is live
		if ( gigaom.$html_body.hasClass( 'theme-preview' ) ) {
			return;
		}//end if

		gigaom.waterfall.$wijax.waypoint( function() {
			var $widget_area = $(this);

			var $el = $widget_area.children('.wijax-excerpt');
			var opts = $.parseJSON( $widget_area.find('.wijax-opts').text() );
			var url = $el.attr('href');

			$.ajax({ 
				url: url,
				dataType: 'script',
				cache: true,
				success: function() {
					// insert the fetched markup

					// prepare a spot for us to do HTML cleanup prior to displaying
					// the new content
					$widget_area.after( '<div id="' + $widget_area.attr('id') + '-staging" style="display:none;" class="wijax-staging" />' );
					var $staging = $( document.getElementById( $widget_area.attr('id') + '-staging' ) );
					$staging.append( window[ opts.varname ] || '' );

					// if there weren't any daybreak elements on load, don't show any
					// on the fetch content. We have to do this with JS because wijax
					// thinks everything is_home()
					if ( ! gigaom.waterfall.$daybreak.length ) {
						$staging.find('.daybreak').remove();
					}//end if

					// hide any daybreaks that aren't showing in the current widget area
					$staging.find('.daybreak').each( function() {
						if ( ! $widget_area.find( '#' + $(this).attr('id') ).length ) {
							$(this).remove();
						}//end if
					});

					// replace the widget area with the staged html
					if ( $staging.children().length ) {
						$widget_area.html( $staging.children() );
						$staging.remove();
					}//end if
				}
			});
		},
		{
			offset: function() {
				return $.waypoints('viewportHeight') + 750;
			},
			triggerOnce: true
		});
	};

	/**
	 * soft reset the waypoints for full width
	 */
	gigaom.waterfall.full = function() {
		gigaom.waterfall.remove_waypoints();
		gigaom.waterfall.add_waypoints();
	};

	/**
	 * phone mode doesn't lazy load in stories
	 */
	gigaom.waterfall.phone = function() {
		gigaom.waterfall.remove_waypoints();
	};

	/**
	 * soft reset the waypoints for tablet
	 */
	gigaom.waterfall.tablet = function() {
		gigaom.waterfall.remove_waypoints();
		gigaom.waterfall.add_waypoints();
	};

	/**
	 * soft remove waypoints (by soft, we mean removes the waypoint triggers
	 * but keeps a record of which waypoints have been reached)
	 */
	gigaom.waterfall.remove_waypoints = function() {
		gigaom.waterfall.$wijax.waypoint('remove');
	};
})( jQuery );
;
go_theme.account_nav = (function( $ ) {
	'use strict';

	var my = {
		nav_loaded: false
	};

	my.init = function() {
		amplify.subscribe( 'go-auth-success', my.reload_nav );
		amplify.subscribe( 'go-auth-fail', my.load_nav );
		amplify.subscribe( 'go-auth-not-authenticated', my.load_nav );
		amplify.subscribe( 'go-auth-reauth', my.reload_nav );

		if ( 'undefined' !== typeof go_remote_identity && go_remote_identity.identity_checked ) {
			my.load_nav();
		}//end if
	};

	my.reload_nav = function() {
		my.nav_loaded = false;
		$('.nav-account').remove();
		$('.sidepanel-nav-account').remove();
		my.load_nav();
	},

	my.load_nav = function() {
		if ( my.nav_loaded ) {
			return;
		}

		var $injection_area = $( document.getElementById( 'go-theme-nav' ) ).find( '.primary .icons.right');
		var logged_in = null !== go_remote_identity.user;
		var $account_item = $('<li class="nav-account"></li>');

		if ( logged_in ) {
			$account_item.addClass( 'sub-nav' );
			$account_item.prepend( '<a href="#">My Account</a>' );
			$account_item.append( '<div class="container"><ul/></div>' );

			var $ul = $account_item.find( 'ul' );

			my.add_nav_links( $ul, go_remote_identity.user.nav );
		} else {
			$account_item.addClass( 'sign-in' );
			$account_item.prepend( '<a class="sign-in-link" href="' + go_remote_identity.login.nav.url + '">' + go_remote_identity.login.nav.title + '</a>' );
		}//end if

		// add to nav
		$injection_area.prepend( $account_item );

		var $sidepanel_item = $account_item.clone();

		if ( logged_in ) {
			$sidepanel_item.addClass( 'sidepanel-nav-account' );
			$sidepanel_item.removeClass( 'sub-nav' );
			var $main_anchor = $sidepanel_item.find( 'a:first' );
			var title = $main_anchor.html();
			$main_anchor.replaceWith( '<h5>' + title + '</h5>' );
			$sidepanel_item.find( 'ul:first' ).unwrap().addClass( 'content' );
		}

		// add to sidepanel
		$('.sidepanel.primary .links > .topics').after( $sidepanel_item );

		var $medium_sidepanel_item = $sidepanel_item.clone();
		$medium_sidepanel_item.find( '.content' ).show();

		// add to sidepanel
		$('.sidepanel.account .links').append( $medium_sidepanel_item );

		my.nav_loaded = true;

		if ( ! logged_in ) {
			return;
		}
		// register a new sidepanel
		gigaom.nav.panels.account = {
			name: 'account',
			direction: 'right',
			control: 'body:not(.go-device-full) .nav-account > a'
		};

		gigaom.nav.init_sidepanel( 'account' );
	};

	my.add_nav_links = function( $container, links ) {
		for ( var i in links ) {
			my.add_nav_link( $container, i, links[ i ] );

			if ( 'undefined' !== typeof links[ i ].nav ) {
				$container.find( '.' + i ).append( '<ul/>' );
				my.add_nav_links( $container.find( 'ul' ), links[ i ].nav );
			}//end if
		}//end for
	};

	my.add_nav_link = function( $container, item_id,  link ) {
		$container.append( '<li class="' + item_id + '"><a href="' + link.url + '">' + link.title + '</a></li>' );
	};

	return my;
}( jQuery ));
;
/*!
 * skrollr core
 *
 * Alexander Prinzhorn - https://github.com/Prinzhorn/skrollr
 *
 * Free to use under terms of MIT license
 */
(function(window, document, undefined) {
	'use strict';

	/*
	 * Global api.
	 */
	var skrollr = {
		get: function() {
			return _instance;
		},
		//Main entry point.
		init: function(options) {
			return _instance || new Skrollr(options);
		},
		VERSION: '0.6.26'
	};

	//Minify optimization.
	var hasProp = Object.prototype.hasOwnProperty;
	var Math = window.Math;
	var getStyle = window.getComputedStyle;

	//They will be filled when skrollr gets initialized.
	var documentElement;
	var body;

	var EVENT_TOUCHSTART = 'touchstart';
	var EVENT_TOUCHMOVE = 'touchmove';
	var EVENT_TOUCHCANCEL = 'touchcancel';
	var EVENT_TOUCHEND = 'touchend';

	var SKROLLABLE_CLASS = 'skrollable';
	var SKROLLABLE_BEFORE_CLASS = SKROLLABLE_CLASS + '-before';
	var SKROLLABLE_BETWEEN_CLASS = SKROLLABLE_CLASS + '-between';
	var SKROLLABLE_AFTER_CLASS = SKROLLABLE_CLASS + '-after';

	var SKROLLR_CLASS = 'skrollr';
	var NO_SKROLLR_CLASS = 'no-' + SKROLLR_CLASS;
	var SKROLLR_DESKTOP_CLASS = SKROLLR_CLASS + '-desktop';
	var SKROLLR_MOBILE_CLASS = SKROLLR_CLASS + '-mobile';

	var DEFAULT_EASING = 'linear';
	var DEFAULT_DURATION = 1000;//ms
	var DEFAULT_MOBILE_DECELERATION = 0.004;//pixel/ms²

	var DEFAULT_SMOOTH_SCROLLING_DURATION = 200;//ms

	var ANCHOR_START = 'start';
	var ANCHOR_END = 'end';
	var ANCHOR_CENTER = 'center';
	var ANCHOR_BOTTOM = 'bottom';

	//The property which will be added to the DOM element to hold the ID of the skrollable.
	var SKROLLABLE_ID_DOM_PROPERTY = '___skrollable_id';

	var rxTouchIgnoreTags = /^(?:input|textarea|button|select)$/i;

	var rxTrim = /^\s+|\s+$/g;

	//Find all data-attributes. data-[_constant]-[offset]-[anchor]-[anchor].
	var rxKeyframeAttribute = /^data(?:-(_\w+))?(?:-?(-?\d*\.?\d+p?))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/;

	var rxPropValue = /\s*(@?[\w\-\[\]]+)\s*:\s*(.+?)\s*(?:;|$)/gi;

	//Easing function names follow the property in square brackets.
	var rxPropEasing = /^(@?[a-z\-]+)\[(\w+)\]$/;

	var rxCamelCase = /-([a-z0-9_])/g;
	var rxCamelCaseFn = function(str, letter) {
		return letter.toUpperCase();
	};

	//Numeric values with optional sign.
	var rxNumericValue = /[\-+]?[\d]*\.?[\d]+/g;

	//Used to replace occurences of {?} with a number.
	var rxInterpolateString = /\{\?\}/g;

	//Finds rgb(a) colors, which don't use the percentage notation.
	var rxRGBAIntegerColor = /rgba?\(\s*-?\d+\s*,\s*-?\d+\s*,\s*-?\d+/g;

	//Finds all gradients.
	var rxGradient = /[a-z\-]+-gradient/g;

	//Vendor prefix. Will be set once skrollr gets initialized.
	var theCSSPrefix = '';
	var theDashedCSSPrefix = '';

	//Will be called once (when skrollr gets initialized).
	var detectCSSPrefix = function() {
		//Only relevant prefixes. May be extended.
		//Could be dangerous if there will ever be a CSS property which actually starts with "ms". Don't hope so.
		var rxPrefixes = /^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/;

		//Detect prefix for current browser by finding the first property using a prefix.
		if(!getStyle) {
			return;
		}

		var style = getStyle(body, null);

		for(var k in style) {
			//We check the key and if the key is a number, we check the value as well, because safari's getComputedStyle returns some weird array-like thingy.
			theCSSPrefix = (k.match(rxPrefixes) || (+k == k && style[k].match(rxPrefixes)));

			if(theCSSPrefix) {
				break;
			}
		}

		//Did we even detect a prefix?
		if(!theCSSPrefix) {
			theCSSPrefix = theDashedCSSPrefix = '';

			return;
		}

		theCSSPrefix = theCSSPrefix[0];

		//We could have detected either a dashed prefix or this camelCaseish-inconsistent stuff.
		if(theCSSPrefix.slice(0,1) === '-') {
			theDashedCSSPrefix = theCSSPrefix;

			//There's no logic behind these. Need a look up.
			theCSSPrefix = ({
				'-webkit-': 'webkit',
				'-moz-': 'Moz',
				'-ms-': 'ms',
				'-o-': 'O'
			})[theCSSPrefix];
		} else {
			theDashedCSSPrefix = '-' + theCSSPrefix.toLowerCase() + '-';
		}
	};

	var polyfillRAF = function() {
		var requestAnimFrame = window.requestAnimationFrame || window[theCSSPrefix.toLowerCase() + 'RequestAnimationFrame'];

		var lastTime = _now();

		if(_isMobile || !requestAnimFrame) {
			requestAnimFrame = function(callback) {
				//How long did it take to render?
				var deltaTime = _now() - lastTime;
				var delay = Math.max(0, 1000 / 60 - deltaTime);

				return window.setTimeout(function() {
					lastTime = _now();
					callback();
				}, delay);
			};
		}

		return requestAnimFrame;
	};

	var polyfillCAF = function() {
		var cancelAnimFrame = window.cancelAnimationFrame || window[theCSSPrefix.toLowerCase() + 'CancelAnimationFrame'];

		if(_isMobile || !cancelAnimFrame) {
			cancelAnimFrame = function(timeout) {
				return window.clearTimeout(timeout);
			};
		}

		return cancelAnimFrame;
	};

	//Built-in easing functions.
	var easings = {
		begin: function() {
			return 0;
		},
		end: function() {
			return 1;
		},
		linear: function(p) {
			return p;
		},
		quadratic: function(p) {
			return p * p;
		},
		cubic: function(p) {
			return p * p * p;
		},
		swing: function(p) {
			return (-Math.cos(p * Math.PI) / 2) + 0.5;
		},
		sqrt: function(p) {
			return Math.sqrt(p);
		},
		outCubic: function(p) {
			return (Math.pow((p - 1), 3) + 1);
		},
		//see https://www.desmos.com/calculator/tbr20s8vd2 for how I did this
		bounce: function(p) {
			var a;

			if(p <= 0.5083) {
				a = 3;
			} else if(p <= 0.8489) {
				a = 9;
			} else if(p <= 0.96208) {
				a = 27;
			} else if(p <= 0.99981) {
				a = 91;
			} else {
				return 1;
			}

			return 1 - Math.abs(3 * Math.cos(p * a * 1.028) / a);
		}
	};

	/**
	 * Constructor.
	 */
	function Skrollr(options) {
		documentElement = document.documentElement;
		body = document.body;

		detectCSSPrefix();

		_instance = this;

		options = options || {};

		_constants = options.constants || {};

		//We allow defining custom easings or overwrite existing.
		if(options.easing) {
			for(var e in options.easing) {
				easings[e] = options.easing[e];
			}
		}

		_edgeStrategy = options.edgeStrategy || 'set';

		_listeners = {
			//Function to be called right before rendering.
			beforerender: options.beforerender,

			//Function to be called right after finishing rendering.
			render: options.render,

			//Function to be called whenever an element with the `data-emit-events` attribute passes a keyframe.
			keyframe: options.keyframe
		};

		//forceHeight is true by default
		_forceHeight = options.forceHeight !== false;

		if(_forceHeight) {
			_scale = options.scale || 1;
		}

		_mobileDeceleration = options.mobileDeceleration || DEFAULT_MOBILE_DECELERATION;

		_smoothScrollingEnabled = options.smoothScrolling !== false;
		_smoothScrollingDuration = options.smoothScrollingDuration || DEFAULT_SMOOTH_SCROLLING_DURATION;

		//Dummy object. Will be overwritten in the _render method when smooth scrolling is calculated.
		_smoothScrolling = {
			targetTop: _instance.getScrollTop()
		};

		//A custom check function may be passed.
		_isMobile = ((options.mobileCheck || function() {
			return (/Android|iPhone|iPad|iPod|BlackBerry/i).test(navigator.userAgent || navigator.vendor || window.opera);
		})());

		if(_isMobile) {
			_skrollrBody = document.getElementById('skrollr-body');

			//Detect 3d transform if there's a skrollr-body (only needed for #skrollr-body).
			if(_skrollrBody) {
				_detect3DTransforms();
			}

			_initMobile();
			_updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_MOBILE_CLASS], [NO_SKROLLR_CLASS]);
		} else {
			_updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS], [NO_SKROLLR_CLASS]);
		}

		//Triggers parsing of elements and a first reflow.
		_instance.refresh();

		_addEvent(window, 'resize orientationchange', function() {
			var width = documentElement.clientWidth;
			var height = documentElement.clientHeight;

			//Only reflow if the size actually changed (#271).
			if(height !== _lastViewportHeight || width !== _lastViewportWidth) {
				_lastViewportHeight = height;
				_lastViewportWidth = width;

				_requestReflow = true;
			}
		});

		var requestAnimFrame = polyfillRAF();

		//Let's go.
		(function animloop(){
			_render();
			_animFrame = requestAnimFrame(animloop);
		}());

		return _instance;
	}

	/**
	 * (Re)parses some or all elements.
	 */
	Skrollr.prototype.refresh = function(elements) {
		var elementIndex;
		var elementsLength;
		var ignoreID = false;

		//Completely reparse anything without argument.
		if(elements === undefined) {
			//Ignore that some elements may already have a skrollable ID.
			ignoreID = true;

			_skrollables = [];
			_skrollableIdCounter = 0;

			elements = document.getElementsByTagName('*');
		} else if(elements.length === undefined) {
			//We also accept a single element as parameter.
			elements = [elements];
		}

		elementIndex = 0;
		elementsLength = elements.length;

		for(; elementIndex < elementsLength; elementIndex++) {
			var el = elements[elementIndex];
			var anchorTarget = el;
			var keyFrames = [];

			//If this particular element should be smooth scrolled.
			var smoothScrollThis = _smoothScrollingEnabled;

			//The edge strategy for this particular element.
			var edgeStrategy = _edgeStrategy;

			//If this particular element should emit keyframe events.
			var emitEvents = false;

			//If we're reseting the counter, remove any old element ids that may be hanging around.
			if(ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {
				delete el[SKROLLABLE_ID_DOM_PROPERTY];
			}

			if(!el.attributes) {
				continue;
			}

			//Iterate over all attributes and search for key frame attributes.
			var attributeIndex = 0;
			var attributesLength = el.attributes.length;

			for (; attributeIndex < attributesLength; attributeIndex++) {
				var attr = el.attributes[attributeIndex];

				if(attr.name === 'data-anchor-target') {
					anchorTarget = document.querySelector(attr.value);

					if(anchorTarget === null) {
						throw 'Unable to find anchor target "' + attr.value + '"';
					}

					continue;
				}

				//Global smooth scrolling can be overridden by the element attribute.
				if(attr.name === 'data-smooth-scrolling') {
					smoothScrollThis = attr.value !== 'off';

					continue;
				}

				//Global edge strategy can be overridden by the element attribute.
				if(attr.name === 'data-edge-strategy') {
					edgeStrategy = attr.value;

					continue;
				}

				//Is this element tagged with the `data-emit-events` attribute?
				if(attr.name === 'data-emit-events') {
					emitEvents = true;

					continue;
				}

				var match = attr.name.match(rxKeyframeAttribute);

				if(match === null) {
					continue;
				}

				var kf = {
					props: attr.value,
					//Point back to the element as well.
					element: el,
					//The name of the event which this keyframe will fire, if emitEvents is
					eventType: attr.name.replace(rxCamelCase, rxCamelCaseFn)
				};

				keyFrames.push(kf);

				var constant = match[1];

				if(constant) {
					//Strip the underscore prefix.
					kf.constant = constant.substr(1);
				}

				//Get the key frame offset.
				var offset = match[2];

				//Is it a percentage offset?
				if(/p$/.test(offset)) {
					kf.isPercentage = true;
					kf.offset = (offset.slice(0, -1) | 0) / 100;
				} else {
					kf.offset = (offset | 0);
				}

				var anchor1 = match[3];

				//If second anchor is not set, the first will be taken for both.
				var anchor2 = match[4] || anchor1;

				//"absolute" (or "classic") mode, where numbers mean absolute scroll offset.
				if(!anchor1 || anchor1 === ANCHOR_START || anchor1 === ANCHOR_END) {
					kf.mode = 'absolute';

					//data-end needs to be calculated after all key frames are known.
					if(anchor1 === ANCHOR_END) {
						kf.isEnd = true;
					} else if(!kf.isPercentage) {
						//For data-start we can already set the key frame w/o calculations.
						//#59: "scale" options should only affect absolute mode.
						kf.offset = kf.offset * _scale;
					}
				}
				//"relative" mode, where numbers are relative to anchors.
				else {
					kf.mode = 'relative';
					kf.anchors = [anchor1, anchor2];
				}
			}

			//Does this element have key frames?
			if(!keyFrames.length) {
				continue;
			}

			//Will hold the original style and class attributes before we controlled the element (see #80).
			var styleAttr, classAttr;

			var id;

			if(!ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {
				//We already have this element under control. Grab the corresponding skrollable id.
				id = el[SKROLLABLE_ID_DOM_PROPERTY];
				styleAttr = _skrollables[id].styleAttr;
				classAttr = _skrollables[id].classAttr;
			} else {
				//It's an unknown element. Asign it a new skrollable id.
				id = (el[SKROLLABLE_ID_DOM_PROPERTY] = _skrollableIdCounter++);
				styleAttr = el.style.cssText;
				classAttr = _getClass(el);
			}

			_skrollables[id] = {
				element: el,
				styleAttr: styleAttr,
				classAttr: classAttr,
				anchorTarget: anchorTarget,
				keyFrames: keyFrames,
				smoothScrolling: smoothScrollThis,
				edgeStrategy: edgeStrategy,
				emitEvents: emitEvents,
				lastFrameIndex: -1
			};

			_updateClass(el, [SKROLLABLE_CLASS], []);
		}

		//Reflow for the first time.
		_reflow();

		//Now that we got all key frame numbers right, actually parse the properties.
		elementIndex = 0;
		elementsLength = elements.length;

		for(; elementIndex < elementsLength; elementIndex++) {
			var sk = _skrollables[elements[elementIndex][SKROLLABLE_ID_DOM_PROPERTY]];

			if(sk === undefined) {
				continue;
			}

			//Parse the property string to objects
			_parseProps(sk);

			//Fill key frames with missing properties from left and right
			_fillProps(sk);
		}

		return _instance;
	};

	/**
	 * Transform "relative" mode to "absolute" mode.
	 * That is, calculate anchor position and offset of element.
	 */
	Skrollr.prototype.relativeToAbsolute = function(element, viewportAnchor, elementAnchor) {
		var viewportHeight = documentElement.clientHeight;
		var box = element.getBoundingClientRect();
		var absolute = box.top;

		//#100: IE doesn't supply "height" with getBoundingClientRect.
		var boxHeight = box.bottom - box.top;

		if(viewportAnchor === ANCHOR_BOTTOM) {
			absolute -= viewportHeight;
		} else if(viewportAnchor === ANCHOR_CENTER) {
			absolute -= viewportHeight / 2;
		}

		if(elementAnchor === ANCHOR_BOTTOM) {
			absolute += boxHeight;
		} else if(elementAnchor === ANCHOR_CENTER) {
			absolute += boxHeight / 2;
		}

		//Compensate scrolling since getBoundingClientRect is relative to viewport.
		absolute += _instance.getScrollTop();

		return (absolute + 0.5) | 0;
	};

	/**
	 * Animates scroll top to new position.
	 */
	Skrollr.prototype.animateTo = function(top, options) {
		options = options || {};

		var now = _now();
		var scrollTop = _instance.getScrollTop();

		//Setting this to a new value will automatically cause the current animation to stop, if any.
		_scrollAnimation = {
			startTop: scrollTop,
			topDiff: top - scrollTop,
			targetTop: top,
			duration: options.duration || DEFAULT_DURATION,
			startTime: now,
			endTime: now + (options.duration || DEFAULT_DURATION),
			easing: easings[options.easing || DEFAULT_EASING],
			done: options.done
		};

		//Don't queue the animation if there's nothing to animate.
		if(!_scrollAnimation.topDiff) {
			if(_scrollAnimation.done) {
				_scrollAnimation.done.call(_instance, false);
			}

			_scrollAnimation = undefined;
		}

		return _instance;
	};

	/**
	 * Stops animateTo animation.
	 */
	Skrollr.prototype.stopAnimateTo = function() {
		if(_scrollAnimation && _scrollAnimation.done) {
			_scrollAnimation.done.call(_instance, true);
		}

		_scrollAnimation = undefined;
	};

	/**
	 * Returns if an animation caused by animateTo is currently running.
	 */
	Skrollr.prototype.isAnimatingTo = function() {
		return !!_scrollAnimation;
	};

	Skrollr.prototype.isMobile = function() {
		return _isMobile;
	};

	Skrollr.prototype.setScrollTop = function(top, force) {
		_forceRender = (force === true);

		if(_isMobile) {
			_mobileOffset = Math.min(Math.max(top, 0), _maxKeyFrame);
		} else {
			window.scrollTo(0, top);
		}

		return _instance;
	};

	Skrollr.prototype.getScrollTop = function() {
		if(_isMobile) {
			return _mobileOffset;
		} else {
			return window.pageYOffset || documentElement.scrollTop || body.scrollTop || 0;
		}
	};

	Skrollr.prototype.getMaxScrollTop = function() {
		return _maxKeyFrame;
	};

	Skrollr.prototype.on = function(name, fn) {
		_listeners[name] = fn;

		return _instance;
	};

	Skrollr.prototype.off = function(name) {
		delete _listeners[name];

		return _instance;
	};

	Skrollr.prototype.destroy = function() {
		var cancelAnimFrame = polyfillCAF();
		cancelAnimFrame(_animFrame);
		_removeAllEvents();

		_updateClass(documentElement, [NO_SKROLLR_CLASS], [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS, SKROLLR_MOBILE_CLASS]);

		var skrollableIndex = 0;
		var skrollablesLength = _skrollables.length;

		for(; skrollableIndex < skrollablesLength; skrollableIndex++) {
			_reset(_skrollables[skrollableIndex].element);
		}

		documentElement.style.overflow = body.style.overflow = '';
		documentElement.style.height = body.style.height = '';

		if(_skrollrBody) {
			skrollr.setStyle(_skrollrBody, 'transform', 'none');
		}

		_instance = undefined;
		_skrollrBody = undefined;
		_listeners = undefined;
		_forceHeight = undefined;
		_maxKeyFrame = 0;
		_scale = 1;
		_constants = undefined;
		_mobileDeceleration = undefined;
		_direction = 'down';
		_lastTop = -1;
		_lastViewportWidth = 0;
		_lastViewportHeight = 0;
		_requestReflow = false;
		_scrollAnimation = undefined;
		_smoothScrollingEnabled = undefined;
		_smoothScrollingDuration = undefined;
		_smoothScrolling = undefined;
		_forceRender = undefined;
		_skrollableIdCounter = 0;
		_edgeStrategy = undefined;
		_isMobile = false;
		_mobileOffset = 0;
		_translateZ = undefined;
	};

	/*
		Private methods.
	*/

	var _initMobile = function() {
		var initialElement;
		var initialTouchY;
		var initialTouchX;
		var currentElement;
		var currentTouchY;
		var currentTouchX;
		var lastTouchY;
		var deltaY;

		var initialTouchTime;
		var currentTouchTime;
		var lastTouchTime;
		var deltaTime;

		_addEvent(documentElement, [EVENT_TOUCHSTART, EVENT_TOUCHMOVE, EVENT_TOUCHCANCEL, EVENT_TOUCHEND].join(' '), function(e) {
			var touch = e.changedTouches[0];

			currentElement = e.target;

			//We don't want text nodes.
			while(currentElement.nodeType === 3) {
				currentElement = currentElement.parentNode;
			}

			currentTouchY = touch.clientY;
			currentTouchX = touch.clientX;
			currentTouchTime = e.timeStamp;

			if(!rxTouchIgnoreTags.test(currentElement.tagName)) {
				e.preventDefault();
			}

			switch(e.type) {
				case EVENT_TOUCHSTART:
					//The last element we tapped on.
					if(initialElement) {
						initialElement.blur();
					}

					_instance.stopAnimateTo();

					initialElement = currentElement;

					initialTouchY = lastTouchY = currentTouchY;
					initialTouchX = currentTouchX;
					initialTouchTime = currentTouchTime;

					break;
				case EVENT_TOUCHMOVE:
					//Prevent default event on touchIgnore elements in case they don't have focus yet.
					if(rxTouchIgnoreTags.test(currentElement.tagName) && document.activeElement !== currentElement) {
						e.preventDefault();
					}

					deltaY = currentTouchY - lastTouchY;
					deltaTime = currentTouchTime - lastTouchTime;

					_instance.setScrollTop(_mobileOffset - deltaY, true);

					lastTouchY = currentTouchY;
					lastTouchTime = currentTouchTime;
					break;
				default:
				case EVENT_TOUCHCANCEL:
				case EVENT_TOUCHEND:
					var distanceY = initialTouchY - currentTouchY;
					var distanceX = initialTouchX - currentTouchX;
					var distance2 = distanceX * distanceX + distanceY * distanceY;

					//Check if it was more like a tap (moved less than 7px).
					if(distance2 < 49) {
						if(!rxTouchIgnoreTags.test(initialElement.tagName)) {
							initialElement.focus();

							//It was a tap, click the element.
							var clickEvent = document.createEvent('MouseEvents');
							clickEvent.initMouseEvent('click', true, true, e.view, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);
							initialElement.dispatchEvent(clickEvent);
						}

						return;
					}

					initialElement = undefined;

					var speed = deltaY / deltaTime;

					//Cap speed at 3 pixel/ms.
					speed = Math.max(Math.min(speed, 3), -3);

					var duration = Math.abs(speed / _mobileDeceleration);
					var targetOffset = speed * duration + 0.5 * _mobileDeceleration * duration * duration;
					var targetTop = _instance.getScrollTop() - targetOffset;

					//Relative duration change for when scrolling above bounds.
					var targetRatio = 0;

					//Change duration proportionally when scrolling would leave bounds.
					if(targetTop > _maxKeyFrame) {
						targetRatio = (_maxKeyFrame - targetTop) / targetOffset;

						targetTop = _maxKeyFrame;
					} else if(targetTop < 0) {
						targetRatio = -targetTop / targetOffset;

						targetTop = 0;
					}

					duration = duration * (1 - targetRatio);

					_instance.animateTo((targetTop + 0.5) | 0, {easing: 'outCubic', duration: duration});
					break;
			}
		});

		//Just in case there has already been some native scrolling, reset it.
		window.scrollTo(0, 0);
		documentElement.style.overflow = body.style.overflow = 'hidden';
	};

	/**
	 * Updates key frames which depend on others / need to be updated on resize.
	 * That is "end" in "absolute" mode and all key frames in "relative" mode.
	 * Also handles constants, because they may change on resize.
	 */
	var _updateDependentKeyFrames = function() {
		var viewportHeight = documentElement.clientHeight;
		var processedConstants = _processConstants();
		var skrollable;
		var element;
		var anchorTarget;
		var keyFrames;
		var keyFrameIndex;
		var keyFramesLength;
		var kf;
		var skrollableIndex;
		var skrollablesLength;
		var offset;
		var constantValue;

		//First process all relative-mode elements and find the max key frame.
		skrollableIndex = 0;
		skrollablesLength = _skrollables.length;

		for(; skrollableIndex < skrollablesLength; skrollableIndex++) {
			skrollable = _skrollables[skrollableIndex];
			element = skrollable.element;
			anchorTarget = skrollable.anchorTarget;
			keyFrames = skrollable.keyFrames;

			keyFrameIndex = 0;
			keyFramesLength = keyFrames.length;

			for(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {
				kf = keyFrames[keyFrameIndex];

				offset = kf.offset;
				constantValue = processedConstants[kf.constant] || 0;

				kf.frame = offset;

				if(kf.isPercentage) {
					//Convert the offset to percentage of the viewport height.
					offset = offset * viewportHeight;

					//Absolute + percentage mode.
					kf.frame = offset;
				}

				if(kf.mode === 'relative') {
					_reset(element);

					kf.frame = _instance.relativeToAbsolute(anchorTarget, kf.anchors[0], kf.anchors[1]) - offset;

					_reset(element, true);
				}

				kf.frame += constantValue;

				//Only search for max key frame when forceHeight is enabled.
				if(_forceHeight) {
					//Find the max key frame, but don't use one of the data-end ones for comparison.
					if(!kf.isEnd && kf.frame > _maxKeyFrame) {
						_maxKeyFrame = kf.frame;
					}
				}
			}
		}

		//#133: The document can be larger than the maxKeyFrame we found.
		_maxKeyFrame = Math.max(_maxKeyFrame, _getDocumentHeight());

		//Now process all data-end keyframes.
		skrollableIndex = 0;
		skrollablesLength = _skrollables.length;

		for(; skrollableIndex < skrollablesLength; skrollableIndex++) {
			skrollable = _skrollables[skrollableIndex];
			keyFrames = skrollable.keyFrames;

			keyFrameIndex = 0;
			keyFramesLength = keyFrames.length;

			for(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {
				kf = keyFrames[keyFrameIndex];

				constantValue = processedConstants[kf.constant] || 0;

				if(kf.isEnd) {
					kf.frame = _maxKeyFrame - kf.offset + constantValue;
				}
			}

			skrollable.keyFrames.sort(_keyFrameComparator);
		}
	};

	/**
	 * Calculates and sets the style properties for the element at the given frame.
	 * @param fakeFrame The frame to render at when smooth scrolling is enabled.
	 * @param actualFrame The actual frame we are at.
	 */
	var _calcSteps = function(fakeFrame, actualFrame) {
		//Iterate over all skrollables.
		var skrollableIndex = 0;
		var skrollablesLength = _skrollables.length;

		for(; skrollableIndex < skrollablesLength; skrollableIndex++) {
			var skrollable = _skrollables[skrollableIndex];
			var element = skrollable.element;
			var frame = skrollable.smoothScrolling ? fakeFrame : actualFrame;
			var frames = skrollable.keyFrames;
			var framesLength = frames.length;
			var firstFrame = frames[0];
			var lastFrame = frames[frames.length - 1];
			var beforeFirst = frame < firstFrame.frame;
			var afterLast = frame > lastFrame.frame;
			var firstOrLastFrame = beforeFirst ? firstFrame : lastFrame;
			var emitEvents = skrollable.emitEvents;
			var lastFrameIndex = skrollable.lastFrameIndex;
			var key;
			var value;

			//If we are before/after the first/last frame, set the styles according to the given edge strategy.
			if(beforeFirst || afterLast) {
				//Check if we already handled this edge case last time.
				//Note: using setScrollTop it's possible that we jumped from one edge to the other.
				if(beforeFirst && skrollable.edge === -1 || afterLast && skrollable.edge === 1) {
					continue;
				}

				//Add the skrollr-before or -after class.
				if(beforeFirst) {
					_updateClass(element, [SKROLLABLE_BEFORE_CLASS], [SKROLLABLE_AFTER_CLASS, SKROLLABLE_BETWEEN_CLASS]);

					//This handles the special case where we exit the first keyframe.
					if(emitEvents && lastFrameIndex > -1) {
						_emitEvent(element, firstFrame.eventType, _direction);
						skrollable.lastFrameIndex = -1;
					}
				} else {
					_updateClass(element, [SKROLLABLE_AFTER_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_BETWEEN_CLASS]);

					//This handles the special case where we exit the last keyframe.
					if(emitEvents && lastFrameIndex < framesLength) {
						_emitEvent(element, lastFrame.eventType, _direction);
						skrollable.lastFrameIndex = framesLength;
					}
				}

				//Remember that we handled the edge case (before/after the first/last keyframe).
				skrollable.edge = beforeFirst ? -1 : 1;

				switch(skrollable.edgeStrategy) {
					case 'reset':
						_reset(element);
						continue;
					case 'ease':
						//Handle this case like it would be exactly at first/last keyframe and just pass it on.
						frame = firstOrLastFrame.frame;
						break;
					default:
					case 'set':
						var props = firstOrLastFrame.props;

						for(key in props) {
							if(hasProp.call(props, key)) {
								value = _interpolateString(props[key].value);

								//Set style or attribute.
								if(key.indexOf('@') === 0) {
									element.setAttribute(key.substr(1), value);
								} else {
									skrollr.setStyle(element, key, value);
								}
							}
						}

						continue;
				}
			} else {
				//Did we handle an edge last time?
				if(skrollable.edge !== 0) {
					_updateClass(element, [SKROLLABLE_CLASS, SKROLLABLE_BETWEEN_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_AFTER_CLASS]);
					skrollable.edge = 0;
				}
			}

			//Find out between which two key frames we are right now.
			var keyFrameIndex = 0;

			for(; keyFrameIndex < framesLength - 1; keyFrameIndex++) {
				if(frame >= frames[keyFrameIndex].frame && frame <= frames[keyFrameIndex + 1].frame) {
					var left = frames[keyFrameIndex];
					var right = frames[keyFrameIndex + 1];

					for(key in left.props) {
						if(hasProp.call(left.props, key)) {
							var progress = (frame - left.frame) / (right.frame - left.frame);

							//Transform the current progress using the given easing function.
							progress = left.props[key].easing(progress);

							//Interpolate between the two values
							value = _calcInterpolation(left.props[key].value, right.props[key].value, progress);

							value = _interpolateString(value);

							//Set style or attribute.
							if(key.indexOf('@') === 0) {
								element.setAttribute(key.substr(1), value);
							} else {
								skrollr.setStyle(element, key, value);
							}
						}
					}

					//Are events enabled on this element?
					//This code handles the usual cases of scrolling through different keyframes.
					//The special cases of before first and after last keyframe are handled above.
					if(emitEvents) {
						//Did we pass a new keyframe?
						if(lastFrameIndex !== keyFrameIndex) {
							if(_direction === 'down') {
								_emitEvent(element, left.eventType, _direction);
							} else {
								_emitEvent(element, right.eventType, _direction);
							}

							skrollable.lastFrameIndex = keyFrameIndex;
						}
					}

					break;
				}
			}
		}
	};

	/**
	 * Renders all elements.
	 */
	var _render = function() {
		if(_requestReflow) {
			_requestReflow = false;
			_reflow();
		}

		//We may render something else than the actual scrollbar position.
		var renderTop = _instance.getScrollTop();

		//If there's an animation, which ends in current render call, call the callback after rendering.
		var afterAnimationCallback;
		var now = _now();
		var progress;

		//Before actually rendering handle the scroll animation, if any.
		if(_scrollAnimation) {
			//It's over
			if(now >= _scrollAnimation.endTime) {
				renderTop = _scrollAnimation.targetTop;
				afterAnimationCallback = _scrollAnimation.done;
				_scrollAnimation = undefined;
			} else {
				//Map the current progress to the new progress using given easing function.
				progress = _scrollAnimation.easing((now - _scrollAnimation.startTime) / _scrollAnimation.duration);

				renderTop = (_scrollAnimation.startTop + progress * _scrollAnimation.topDiff) | 0;
			}

			_instance.setScrollTop(renderTop, true);
		}
		//Smooth scrolling only if there's no animation running and if we're not forcing the rendering.
		else if(!_forceRender) {
			var smoothScrollingDiff = _smoothScrolling.targetTop - renderTop;

			//The user scrolled, start new smooth scrolling.
			if(smoothScrollingDiff) {
				_smoothScrolling = {
					startTop: _lastTop,
					topDiff: renderTop - _lastTop,
					targetTop: renderTop,
					startTime: _lastRenderCall,
					endTime: _lastRenderCall + _smoothScrollingDuration
				};
			}

			//Interpolate the internal scroll position (not the actual scrollbar).
			if(now <= _smoothScrolling.endTime) {
				//Map the current progress to the new progress using easing function.
				progress = easings.sqrt((now - _smoothScrolling.startTime) / _smoothScrollingDuration);

				renderTop = (_smoothScrolling.startTop + progress * _smoothScrolling.topDiff) | 0;
			}
		}

		//That's were we actually "scroll" on mobile.
		if(_isMobile && _skrollrBody) {
			//Set the transform ("scroll it").
			skrollr.setStyle(_skrollrBody, 'transform', 'translate(0, ' + -(_mobileOffset) + 'px) ' + _translateZ);
		}

		//Did the scroll position even change?
		if(_forceRender || _lastTop !== renderTop) {
			//Remember in which direction are we scrolling?
			_direction = (renderTop > _lastTop) ? 'down' : (renderTop < _lastTop ? 'up' : _direction);

			_forceRender = false;

			var listenerParams = {
				curTop: renderTop,
				lastTop: _lastTop,
				maxTop: _maxKeyFrame,
				direction: _direction
			};

			//Tell the listener we are about to render.
			var continueRendering = _listeners.beforerender && _listeners.beforerender.call(_instance, listenerParams);

			//The beforerender listener function is able the cancel rendering.
			if(continueRendering !== false) {
				//Now actually interpolate all the styles.
				_calcSteps(renderTop, _instance.getScrollTop());

				//Remember when we last rendered.
				_lastTop = renderTop;

				if(_listeners.render) {
					_listeners.render.call(_instance, listenerParams);
				}
			}

			if(afterAnimationCallback) {
				afterAnimationCallback.call(_instance, false);
			}
		}

		_lastRenderCall = now;
	};

	/**
	 * Parses the properties for each key frame of the given skrollable.
	 */
	var _parseProps = function(skrollable) {
		//Iterate over all key frames
		var keyFrameIndex = 0;
		var keyFramesLength = skrollable.keyFrames.length;

		for(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {
			var frame = skrollable.keyFrames[keyFrameIndex];
			var easing;
			var value;
			var prop;
			var props = {};

			var match;

			while((match = rxPropValue.exec(frame.props)) !== null) {
				prop = match[1];
				value = match[2];

				easing = prop.match(rxPropEasing);

				//Is there an easing specified for this prop?
				if(easing !== null) {
					prop = easing[1];
					easing = easing[2];
				} else {
					easing = DEFAULT_EASING;
				}

				//Exclamation point at first position forces the value to be taken literal.
				value = value.indexOf('!') ? _parseProp(value) : [value.slice(1)];

				//Save the prop for this key frame with his value and easing function
				props[prop] = {
					value: value,
					easing: easings[easing]
				};
			}

			frame.props = props;
		}
	};

	/**
	 * Parses a value extracting numeric values and generating a format string
	 * for later interpolation of the new values in old string.
	 *
	 * @param val The CSS value to be parsed.
	 * @return Something like ["rgba(?%,?%, ?%,?)", 100, 50, 0, .7]
	 * where the first element is the format string later used
	 * and all following elements are the numeric value.
	 */
	var _parseProp = function(val) {
		var numbers = [];

		//One special case, where floats don't work.
		//We replace all occurences of rgba colors
		//which don't use percentage notation with the percentage notation.
		rxRGBAIntegerColor.lastIndex = 0;
		val = val.replace(rxRGBAIntegerColor, function(rgba) {
			return rgba.replace(rxNumericValue, function(n) {
				return n / 255 * 100 + '%';
			});
		});

		//Handle prefixing of "gradient" values.
		//For now only the prefixed value will be set. Unprefixed isn't supported anyway.
		if(theDashedCSSPrefix) {
			rxGradient.lastIndex = 0;
			val = val.replace(rxGradient, function(s) {
				return theDashedCSSPrefix + s;
			});
		}

		//Now parse ANY number inside this string and create a format string.
		val = val.replace(rxNumericValue, function(n) {
			numbers.push(+n);
			return '{?}';
		});

		//Add the formatstring as first value.
		numbers.unshift(val);

		return numbers;
	};

	/**
	 * Fills the key frames with missing left and right hand properties.
	 * If key frame 1 has property X and key frame 2 is missing X,
	 * but key frame 3 has X again, then we need to assign X to key frame 2 too.
	 *
	 * @param sk A skrollable.
	 */
	var _fillProps = function(sk) {
		//Will collect the properties key frame by key frame
		var propList = {};
		var keyFrameIndex;
		var keyFramesLength;

		//Iterate over all key frames from left to right
		keyFrameIndex = 0;
		keyFramesLength = sk.keyFrames.length;

		for(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {
			_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);
		}

		//Now do the same from right to fill the last gaps

		propList = {};

		//Iterate over all key frames from right to left
		keyFrameIndex = sk.keyFrames.length - 1;

		for(; keyFrameIndex >= 0; keyFrameIndex--) {
			_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);
		}
	};

	var _fillPropForFrame = function(frame, propList) {
		var key;

		//For each key frame iterate over all right hand properties and assign them,
		//but only if the current key frame doesn't have the property by itself
		for(key in propList) {
			//The current frame misses this property, so assign it.
			if(!hasProp.call(frame.props, key)) {
				frame.props[key] = propList[key];
			}
		}

		//Iterate over all props of the current frame and collect them
		for(key in frame.props) {
			propList[key] = frame.props[key];
		}
	};

	/**
	 * Calculates the new values for two given values array.
	 */
	var _calcInterpolation = function(val1, val2, progress) {
		var valueIndex;
		var val1Length = val1.length;

		//They both need to have the same length
		if(val1Length !== val2.length) {
			throw 'Can\'t interpolate between "' + val1[0] + '" and "' + val2[0] + '"';
		}

		//Add the format string as first element.
		var interpolated = [val1[0]];

		valueIndex = 1;

		for(; valueIndex < val1Length; valueIndex++) {
			//That's the line where the two numbers are actually interpolated.
			interpolated[valueIndex] = val1[valueIndex] + ((val2[valueIndex] - val1[valueIndex]) * progress);
		}

		return interpolated;
	};

	/**
	 * Interpolates the numeric values into the format string.
	 */
	var _interpolateString = function(val) {
		var valueIndex = 1;

		rxInterpolateString.lastIndex = 0;

		return val[0].replace(rxInterpolateString, function() {
			return val[valueIndex++];
		});
	};

	/**
	 * Resets the class and style attribute to what it was before skrollr manipulated the element.
	 * Also remembers the values it had before reseting, in order to undo the reset.
	 */
	var _reset = function(elements, undo) {
		//We accept a single element or an array of elements.
		elements = [].concat(elements);

		var skrollable;
		var element;
		var elementsIndex = 0;
		var elementsLength = elements.length;

		for(; elementsIndex < elementsLength; elementsIndex++) {
			element = elements[elementsIndex];
			skrollable = _skrollables[element[SKROLLABLE_ID_DOM_PROPERTY]];

			//Couldn't find the skrollable for this DOM element.
			if(!skrollable) {
				continue;
			}

			if(undo) {
				//Reset class and style to the "dirty" (set by skrollr) values.
				element.style.cssText = skrollable.dirtyStyleAttr;
				_updateClass(element, skrollable.dirtyClassAttr);
			} else {
				//Remember the "dirty" (set by skrollr) class and style.
				skrollable.dirtyStyleAttr = element.style.cssText;
				skrollable.dirtyClassAttr = _getClass(element);

				//Reset class and style to what it originally was.
				element.style.cssText = skrollable.styleAttr;
				_updateClass(element, skrollable.classAttr);
			}
		}
	};

	/**
	 * Detects support for 3d transforms by applying it to the skrollr-body.
	 */
	var _detect3DTransforms = function() {
		_translateZ = 'translateZ(0)';
		skrollr.setStyle(_skrollrBody, 'transform', _translateZ);

		var computedStyle = getStyle(_skrollrBody);
		var computedTransform = computedStyle.getPropertyValue('transform');
		var computedTransformWithPrefix = computedStyle.getPropertyValue(theDashedCSSPrefix + 'transform');
		var has3D = (computedTransform && computedTransform !== 'none') || (computedTransformWithPrefix && computedTransformWithPrefix !== 'none');

		if(!has3D) {
			_translateZ = '';
		}
	};

	/**
	 * Set the CSS property on the given element. Sets prefixed properties as well.
	 */
	skrollr.setStyle = function(el, prop, val) {
		var style = el.style;

		//Camel case.
		prop = prop.replace(rxCamelCase, rxCamelCaseFn).replace('-', '');

		//Make sure z-index gets a <integer>.
		//This is the only <integer> case we need to handle.
		if(prop === 'zIndex') {
			if(isNaN(val)) {
				//If it's not a number, don't touch it.
				//It could for example be "auto" (#351).
				style[prop] = val;
			} else {
				//Floor the number.
				style[prop] = '' + (val | 0);
			}
		}
		//#64: "float" can't be set across browsers. Needs to use "cssFloat" for all except IE.
		else if(prop === 'float') {
			style.styleFloat = style.cssFloat = val;
		}
		else {
			//Need try-catch for old IE.
			try {
				//Set prefixed property if there's a prefix.
				if(theCSSPrefix) {
					style[theCSSPrefix + prop.slice(0,1).toUpperCase() + prop.slice(1)] = val;
				}

				//Set unprefixed.
				style[prop] = val;
			} catch(ignore) {}
		}
	};

	/**
	 * Cross browser event handling.
	 */
	var _addEvent = skrollr.addEvent = function(element, names, callback) {
		var intermediate = function(e) {
			//Normalize IE event stuff.
			e = e || window.event;

			if(!e.target) {
				e.target = e.srcElement;
			}

			if(!e.preventDefault) {
				e.preventDefault = function() {
					e.returnValue = false;
					e.defaultPrevented = true;
				};
			}

			return callback.call(this, e);
		};

		names = names.split(' ');

		var name;
		var nameCounter = 0;
		var namesLength = names.length;

		for(; nameCounter < namesLength; nameCounter++) {
			name = names[nameCounter];

			if(element.addEventListener) {
				element.addEventListener(name, callback, false);
			} else {
				element.attachEvent('on' + name, intermediate);
			}

			//Remember the events to be able to flush them later.
			_registeredEvents.push({
				element: element,
				name: name,
				listener: callback
			});
		}
	};

	var _removeEvent = skrollr.removeEvent = function(element, names, callback) {
		names = names.split(' ');

		var nameCounter = 0;
		var namesLength = names.length;

		for(; nameCounter < namesLength; nameCounter++) {
			if(element.removeEventListener) {
				element.removeEventListener(names[nameCounter], callback, false);
			} else {
				element.detachEvent('on' + names[nameCounter], callback);
			}
		}
	};

	var _removeAllEvents = function() {
		var eventData;
		var eventCounter = 0;
		var eventsLength = _registeredEvents.length;

		for(; eventCounter < eventsLength; eventCounter++) {
			eventData = _registeredEvents[eventCounter];

			_removeEvent(eventData.element, eventData.name, eventData.listener);
		}

		_registeredEvents = [];
	};

	var _emitEvent = function(element, name, direction) {
		if(_listeners.keyframe) {
			_listeners.keyframe.call(_instance, element, name, direction);
		}
	};

	var _reflow = function() {
		var pos = _instance.getScrollTop();

		//Will be recalculated by _updateDependentKeyFrames.
		_maxKeyFrame = 0;

		if(_forceHeight && !_isMobile) {
			//un-"force" the height to not mess with the calculations in _updateDependentKeyFrames (#216).
			body.style.height = '';
		}

		_updateDependentKeyFrames();

		if(_forceHeight && !_isMobile) {
			//"force" the height.
			body.style.height = (_maxKeyFrame + documentElement.clientHeight) + 'px';
		}

		//The scroll offset may now be larger than needed (on desktop the browser/os prevents scrolling farther than the bottom).
		if(_isMobile) {
			_instance.setScrollTop(Math.min(_instance.getScrollTop(), _maxKeyFrame));
		} else {
			//Remember and reset the scroll pos (#217).
			_instance.setScrollTop(pos, true);
		}

		_forceRender = true;
	};

	/*
	 * Returns a copy of the constants object where all functions and strings have been evaluated.
	 */
	var _processConstants = function() {
		var viewportHeight = documentElement.clientHeight;
		var copy = {};
		var prop;
		var value;

		for(prop in _constants) {
			value = _constants[prop];

			if(typeof value === 'function') {
				value = value.call(_instance);
			}
			//Percentage offset.
			else if((/p$/).test(value)) {
				value = (value.slice(0, -1) / 100) * viewportHeight;
			}

			copy[prop] = value;
		}

		return copy;
	};

	/*
	 * Returns the height of the document.
	 */
	var _getDocumentHeight = function() {
		var skrollrBodyHeight = (_skrollrBody && _skrollrBody.offsetHeight || 0);
		var bodyHeight = Math.max(skrollrBodyHeight, body.scrollHeight, body.offsetHeight, documentElement.scrollHeight, documentElement.offsetHeight, documentElement.clientHeight);

		return bodyHeight - documentElement.clientHeight;
	};

	/**
	 * Returns a string of space separated classnames for the current element.
	 * Works with SVG as well.
	 */
	var _getClass = function(element) {
		var prop = 'className';

		//SVG support by using className.baseVal instead of just className.
		if(window.SVGElement && element instanceof window.SVGElement) {
			element = element[prop];
			prop = 'baseVal';
		}

		return element[prop];
	};

	/**
	 * Adds and removes a CSS classes.
	 * Works with SVG as well.
	 * add and remove are arrays of strings,
	 * or if remove is ommited add is a string and overwrites all classes.
	 */
	var _updateClass = function(element, add, remove) {
		var prop = 'className';

		//SVG support by using className.baseVal instead of just className.
		if(window.SVGElement && element instanceof window.SVGElement) {
			element = element[prop];
			prop = 'baseVal';
		}

		//When remove is ommited, we want to overwrite/set the classes.
		if(remove === undefined) {
			element[prop] = add;
			return;
		}

		//Cache current classes. We will work on a string before passing back to DOM.
		var val = element[prop];

		//All classes to be removed.
		var classRemoveIndex = 0;
		var removeLength = remove.length;

		for(; classRemoveIndex < removeLength; classRemoveIndex++) {
			val = _untrim(val).replace(_untrim(remove[classRemoveIndex]), ' ');
		}

		val = _trim(val);

		//All classes to be added.
		var classAddIndex = 0;
		var addLength = add.length;

		for(; classAddIndex < addLength; classAddIndex++) {
			//Only add if el not already has class.
			if(_untrim(val).indexOf(_untrim(add[classAddIndex])) === -1) {
				val += ' ' + add[classAddIndex];
			}
		}

		element[prop] = _trim(val);
	};

	var _trim = function(a) {
		return a.replace(rxTrim, '');
	};

	/**
	 * Adds a space before and after the string.
	 */
	var _untrim = function(a) {
		return ' ' + a + ' ';
	};

	var _now = Date.now || function() {
		return +new Date();
	};

	var _keyFrameComparator = function(a, b) {
		return a.frame - b.frame;
	};

	/*
	 * Private variables.
	 */

	//Singleton
	var _instance;

	/*
		A list of all elements which should be animated associated with their the metadata.
		Exmaple skrollable with two key frames animating from 100px width to 20px:

		skrollable = {
			element: <the DOM element>,
			styleAttr: <style attribute of the element before skrollr>,
			classAttr: <class attribute of the element before skrollr>,
			keyFrames: [
				{
					frame: 100,
					props: {
						width: {
							value: ['{?}px', 100],
							easing: <reference to easing function>
						}
					},
					mode: "absolute"
				},
				{
					frame: 200,
					props: {
						width: {
							value: ['{?}px', 20],
							easing: <reference to easing function>
						}
					},
					mode: "absolute"
				}
			]
		};
	*/
	var _skrollables;

	var _skrollrBody;

	var _listeners;
	var _forceHeight;
	var _maxKeyFrame = 0;

	var _scale = 1;
	var _constants;

	var _mobileDeceleration;

	//Current direction (up/down).
	var _direction = 'down';

	//The last top offset value. Needed to determine direction.
	var _lastTop = -1;

	//The last time we called the render method (doesn't mean we rendered!).
	var _lastRenderCall = _now();

	//For detecting if it actually resized (#271).
	var _lastViewportWidth = 0;
	var _lastViewportHeight = 0;

	var _requestReflow = false;

	//Will contain data about a running scrollbar animation, if any.
	var _scrollAnimation;

	var _smoothScrollingEnabled;

	var _smoothScrollingDuration;

	//Will contain settins for smooth scrolling if enabled.
	var _smoothScrolling;

	//Can be set by any operation/event to force rendering even if the scrollbar didn't move.
	var _forceRender;

	//Each skrollable gets an unique ID incremented for each skrollable.
	//The ID is the index in the _skrollables array.
	var _skrollableIdCounter = 0;

	var _edgeStrategy;


	//Mobile specific vars. Will be stripped by UglifyJS when not in use.
	var _isMobile = false;

	//The virtual scroll offset when using mobile scrolling.
	var _mobileOffset = 0;

	//If the browser supports 3d transforms, this will be filled with 'translateZ(0)' (empty string otherwise).
	var _translateZ;

	//Will contain data about registered events by skrollr.
	var _registeredEvents = [];

	//Animation frame id returned by RequestAnimationFrame (or timeout when RAF is not supported).
	var _animFrame;

	//Expose skrollr as either a global variable or a require.js module
	if(typeof define === 'function' && define.amd) {
		define('skrollr', function () {
			return skrollr;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = skrollr;
	} else {
		window.skrollr = skrollr;
	}

}(window, document));
;
// let's define console.log if it doesn't exist
if ( 'undefined' === typeof console ) {
	window.console = {
		dir: function (){},
		error: function (){},
		info: function (){},
		log: function (){}
	};
}

// load the calc polyfill if the browser doesn't support it: https://github.com/closingtag/calc-polyfill
Modernizr.load({
	test: Modernizr.csscalc,
	nope: go_theme.template_url + '/js/min/external/calc.js'
});

go_theme.child = {};

( function( $ ) {
	'use strict';

	$(document).foundation();

	go_theme.child.init = function() {
		amplify.subscribe( 'go-resize-execute', go_theme.child.resize );
		amplify.subscribe( 'go-resize-phone', go_theme.child.resize );

		go_theme.child.resize();

		// make sure the height of the page is at least the height of the window
		amplify.subscribe( 'go-resize-execute', go_theme.child.resize_html );

		// if there is a ribbon-cta, add a class to the body
		if ( $( '#research-ribbon-cta' ).length ) {
			$( 'body' ).addClass( 'has-ribbon-cta' );
		}//end if
	};

	go_theme.child.resize = function() {
		$(document).foundation('section','reflow');
		$('.widget.go-report-featured').each( function() {
			var $el = $(this);
			var $article = $el.find( '.go-report-featured.quarterly-wrap-up' );

			if ( $('body').hasClass( 'go-device-phone' ) ) {
				$article.css( 'height', 'auto' );
				return;
			}//end if

			if ( 0 === $article.length ) {
				return;
			}//end if

			if ( $article.height() === $el.innerHeight() ) {
				return;
			}//end if

			// set the height based on the widget, ignoring article padding
			$article.height( $el.innerHeight() - ( $article.outerHeight() - $article.height() ) );
		});

		$('.widget.go-event-waterfall article').each( function() {
			var $el = $(this);
			var $info = $el.find( '.info' );
			var $article = $el.find( 'section.body' );

			if ( $('body').hasClass( 'go-device-phone' ) ) {
				$info.css( 'height', 'auto' );
				return;
			}//end if

			if ( 0 === $info.length ) {
				return;
			}//end if

			if ( $info.height() === $el.innerHeight() ) {
				return;
			}//end if

			// set the height based on the widget, ignoring article padding
			$info.height( $el.innerHeight() - ( $info.outerHeight() - $info.height() ) );

			if ( $('body').hasClass( 'go-device-phone' ) ) {
				$article.css( 'height', 'auto' );
				return;
			}//end if

			if ( 0 === $article.length ) {
				return;
			}//end if

			if ( $article.height() === $el.innerHeight() ) {
				return;
			}//end if

			// set the height based on the widget, ignoring article padding
			$article.height( $el.innerHeight() - ( $article.outerHeight() - $article.height() ) );

			if ( ! $el.hasClass( 'resized' ) ) {
				$el.addClass('resized');
			}//end if
		});
	};

	go_theme.child.resize_html = function() {
		var window_height = $(window).height();
		var wrap_height = gigaom.$wrapper.height();

		var height_diff = window_height - wrap_height;
		var main_padding_bottom = gigaom.$main.css('padding-bottom');

		if ( 'undefined' === typeof main_padding_bottom ) {
			main_padding_bottom = '0';
		}//end if

		main_padding_bottom = parseInt( main_padding_bottom.replace('px', ''), 10 );

		if ( height_diff < 0 ) {
			gigaom.$main.css('padding-bottom', '');

			main_padding_bottom = gigaom.$main.css('padding-bottom');

			if ( 'undefined' === typeof main_padding_bottom ) {
				main_padding_bottom = '0';
			}//end if

			main_padding_bottom = parseInt( main_padding_bottom.replace('px', ''), 10 );

			wrap_height = gigaom.$wrapper.height();
			height_diff = window_height - wrap_height;
		}//end if

		var $foot = $( document.getElementById( 'foot' ) );

		// the footer is hidden by default to avoid jumpiness.  If it is hidden, let's show it
		if ( 'hidden' === $foot.css( 'visibility' ) ) {

			// first, we'll want to resize the #main content area
			if ( height_diff > 0 ) {
				gigaom.$main.css('padding-bottom', main_padding_bottom + height_diff );
			}//end if

			// display the footer
			$foot.css( 'visibility', 'visible' );
			//adding to prevent skrollr messing up the footer
			$( document ).trigger( 'go-theme-child-footer-shown' );
		} else if ( height_diff > 0 ) {
			// now that the footer is visible, let's add an animation if we're resizing the main content area
			gigaom.$main.animate( { paddingBottom: main_padding_bottom + height_diff } );
		}//end else if

		$( '.single-post .post-social:not(.above-featured)' ).removeClass( 'sticky' );
	};//end go_theme.child.resize_html
})( jQuery );

jQuery( function( $ ) {
	'use strict';

	gigaom.init();

	$(document).foundation( 'tooltips' );

	$( 'img[usemap]' ).rwdImageMaps();

	go_theme.account_nav.init();

	$( document.getElementById( 'related-research-target' ) ).bumpdown();

	// Support for search hover stuff
	$(document).on( 'mouseover touchstart tap MSPointerDown', '.property-search #sidebar .widget_scriblio_facets .term-link', function() {
		$(this).closest('li').addClass('hover');
	});

	$(document).on( 'mouseout touchend tap MSPointerOut', '.property-search #sidebar .widget_scriblio_facets .term-link', function() {
		$(this).closest('li').removeClass('hover');
	});

	go_theme.child.init();
});
;
if ( typeof gigaom == 'undefined' ) {
	var gigaom = {};
}//end if

(function( $ ) {
	// during the theme init process, determine what channel we're in
	// based on the class in the body and store that in gigaom.channel
	amplify.subscribe( 'go-pre-init', function() {
		// determine channel
		var body_classes = gigaom.$html_body.attr('class').split(' ');
		var channel = $.grep( body_classes, function( value, index ) {
			return 'go-channel-' === value.substring( 0, 11 );
		});

		if ( typeof channel[0] == 'undefined' ) {
			gigaom.channel = '';
		} else {
			gigaom.channel = channel[0].replace('go-channel-', '');
		}//end else
	});
})( jQuery );
;
window.PushUpNotifications=function(e,t){"use strict";function i(){var e="pushup_pv=";var t=n.cookie.split(";");for(var r=0;r<t.length;r++){var i=t[r].trim();if(i.indexOf(e)===0){return parseInt(i.substring(e.length,i.length))}}return 0}function s(e){var t=new Date;t.setTime(t.getTime()+60*24*60*60*1e3);var r=t.toUTCString();n.cookie="pushup_pv="+e+";"+"expires="+r+";"+"path=/;"}function o(t){if(u()){if(!t&&r.prompt>1){var a=i()+1;if(r.prompt>a){s(a);return}}if(r.button!==null){r.button.style.display="none"}n.cookie="pushup_pv=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/;";var f={userID:r.userID,domain:r.domain};try{e.safari.pushNotification.requestPermission(r.webServiceURL,r.websitePushID,f,o)}catch(l){r.permissionData.permission="denied"}}}function u(){return typeof r.permissionData.permission!=="undefined"&&r.permissionData.permission==="default"}function a(){if("safari"in e&&"pushNotification"in e.safari){r.userID=t.userID;r.domain=t.domain;r.websitePushID=t.websitePushID;r.webServiceURL=t.webServiceURL;r.prompt=t.prompt;r.permissionData=e.safari.pushNotification.permission(r.websitePushID);if(r.prompt>0){o(false)}}if(n.querySelector){r.button=n.querySelector(".pushup_button");if(r.button!==null){if(u()){r.button.style.display="block";r.button.addEventListener("click",function(e){e.preventDefault();o(true)},false)}else{r.button.style.display="none"}}}}var n=e.document;var r={websitePushID:"",webServiceURL:"",userID:-1,domain:"",prompt:1,permissionData:"",button:null};a();return{offerNotifications:o,canOfferNotifications:u}}(window,PushUpNotificationSettings);window.PushUpNotifications.version="1.2.1"
;
var go_remote_identity = {
	user         : null,
	auth_type    : null,
	logged_in_as : null,
	identity_checked: false,
	login        : {}
};

/**
 * jQuery GoIdentity SDK
 * @author Gigaom
 *
 * Defines data handler functions for JSONP data returned from
 * Pro authentication services.
 */
(function( $ ){
	'use strict';
	var $post_content = $('div[id^="post-content-"]');

	var methods = {

		/**
		 * init method to execute upon JSONP return
		 *
		 * Checks for the presence of a user object
		 * @TODO: make this more dynamic, i.e. include a way
		 * to determine from the returned JSONP which method to
		 * execute within init
		 * @param user An object containing user data
		 */
		init : function( user ) {
			go_remote_identity.logged_in_as = $('body').data('logged-in-as');

			if ( user === null || user === undefined ) {
				return false;
			}
		},

		/**
		 * get identity_server
		 */
		get_identity_server: function() {
			var server = go_remote_identity_data.identity_server;

			server = server.replace( /https?:/, '' );
			server = document.location.protocol + server;

			return server;
		},

		/**
		 * get sign_in_url
		 */
		get_sign_in_url: function() {
			var url = go_remote_identity_data.sign_in;

			url = url.replace( /https?:/, '' );
			url = document.location.protocol + url;

			return url;
		},

		/**
		 * gets the current URL with a callback
		 */
		get_current_url: function( call_back ) {
			return document.location.href + call_back;
		},

		get_gravatar: function( email, size ) {

			// MD5 (Message-Digest Algorithm) by WebToolkit
			// http://www.webtoolkit.info/javascript-md5.html

			var MD5=function(s){function L(k,d){return(k<<d)|(k>>>(32-d))}function K(G,k){var I,d,F,H,x;F=(G&2147483648);H=(k&2147483648);I=(G&1073741824);d=(k&1073741824);x=(G&1073741823)+(k&1073741823);if(I&d){return(x^2147483648^F^H)}if(I|d){if(x&1073741824){return(x^3221225472^F^H)}else{return(x^1073741824^F^H)}}else{return(x^F^H)}}function r(d,F,k){return(d&F)|((~d)&k)}function q(d,F,k){return(d&k)|(F&(~k))}function p(d,F,k){return(d^F^k)}function n(d,F,k){return(F^(d|(~k)))}function u(G,F,aa,Z,k,H,I){G=K(G,K(K(r(F,aa,Z),k),I));return K(L(G,H),F)}function f(G,F,aa,Z,k,H,I){G=K(G,K(K(q(F,aa,Z),k),I));return K(L(G,H),F)}function D(G,F,aa,Z,k,H,I){G=K(G,K(K(p(F,aa,Z),k),I));return K(L(G,H),F)}function t(G,F,aa,Z,k,H,I){G=K(G,K(K(n(F,aa,Z),k),I));return K(L(G,H),F)}function e(G){var Z;var F=G.length;var x=F+8;var k=(x-(x%64))/64;var I=(k+1)*16;var aa=Array(I-1);var d=0;var H=0;while(H<F){Z=(H-(H%4))/4;d=(H%4)*8;aa[Z]=(aa[Z]|(G.charCodeAt(H)<<d));H++}Z=(H-(H%4))/4;d=(H%4)*8;aa[Z]=aa[Z]|(128<<d);aa[I-2]=F<<3;aa[I-1]=F>>>29;return aa}function B(x){var k="",F="",G,d;for(d=0;d<=3;d++){G=(x>>>(d*8))&255;F="0"+G.toString(16);k=k+F.substr(F.length-2,2)}return k}function J(k){k=k.replace(/\r\n/g,"\n");var d="";for(var F=0;F<k.length;F++){var x=k.charCodeAt(F);if(x<128){d+=String.fromCharCode(x)}else{if((x>127)&&(x<2048)){d+=String.fromCharCode((x>>6)|192);d+=String.fromCharCode((x&63)|128)}else{d+=String.fromCharCode((x>>12)|224);d+=String.fromCharCode(((x>>6)&63)|128);d+=String.fromCharCode((x&63)|128)}}}return d}var C=Array();var P,h,E,v,g,Y,X,W,V;var S=7,Q=12,N=17,M=22;var A=5,z=9,y=14,w=20;var o=4,m=11,l=16,j=23;var U=6,T=10,R=15,O=21;s=J(s);C=e(s);Y=1732584193;X=4023233417;W=2562383102;V=271733878;for(P=0;P<C.length;P+=16){h=Y;E=X;v=W;g=V;Y=u(Y,X,W,V,C[P+0],S,3614090360);V=u(V,Y,X,W,C[P+1],Q,3905402710);W=u(W,V,Y,X,C[P+2],N,606105819);X=u(X,W,V,Y,C[P+3],M,3250441966);Y=u(Y,X,W,V,C[P+4],S,4118548399);V=u(V,Y,X,W,C[P+5],Q,1200080426);W=u(W,V,Y,X,C[P+6],N,2821735955);X=u(X,W,V,Y,C[P+7],M,4249261313);Y=u(Y,X,W,V,C[P+8],S,1770035416);V=u(V,Y,X,W,C[P+9],Q,2336552879);W=u(W,V,Y,X,C[P+10],N,4294925233);X=u(X,W,V,Y,C[P+11],M,2304563134);Y=u(Y,X,W,V,C[P+12],S,1804603682);V=u(V,Y,X,W,C[P+13],Q,4254626195);W=u(W,V,Y,X,C[P+14],N,2792965006);X=u(X,W,V,Y,C[P+15],M,1236535329);Y=f(Y,X,W,V,C[P+1],A,4129170786);V=f(V,Y,X,W,C[P+6],z,3225465664);W=f(W,V,Y,X,C[P+11],y,643717713);X=f(X,W,V,Y,C[P+0],w,3921069994);Y=f(Y,X,W,V,C[P+5],A,3593408605);V=f(V,Y,X,W,C[P+10],z,38016083);W=f(W,V,Y,X,C[P+15],y,3634488961);X=f(X,W,V,Y,C[P+4],w,3889429448);Y=f(Y,X,W,V,C[P+9],A,568446438);V=f(V,Y,X,W,C[P+14],z,3275163606);W=f(W,V,Y,X,C[P+3],y,4107603335);X=f(X,W,V,Y,C[P+8],w,1163531501);Y=f(Y,X,W,V,C[P+13],A,2850285829);V=f(V,Y,X,W,C[P+2],z,4243563512);W=f(W,V,Y,X,C[P+7],y,1735328473);X=f(X,W,V,Y,C[P+12],w,2368359562);Y=D(Y,X,W,V,C[P+5],o,4294588738);V=D(V,Y,X,W,C[P+8],m,2272392833);W=D(W,V,Y,X,C[P+11],l,1839030562);X=D(X,W,V,Y,C[P+14],j,4259657740);Y=D(Y,X,W,V,C[P+1],o,2763975236);V=D(V,Y,X,W,C[P+4],m,1272893353);W=D(W,V,Y,X,C[P+7],l,4139469664);X=D(X,W,V,Y,C[P+10],j,3200236656);Y=D(Y,X,W,V,C[P+13],o,681279174);V=D(V,Y,X,W,C[P+0],m,3936430074);W=D(W,V,Y,X,C[P+3],l,3572445317);X=D(X,W,V,Y,C[P+6],j,76029189);Y=D(Y,X,W,V,C[P+9],o,3654602809);V=D(V,Y,X,W,C[P+12],m,3873151461);W=D(W,V,Y,X,C[P+15],l,530742520);X=D(X,W,V,Y,C[P+2],j,3299628645);Y=t(Y,X,W,V,C[P+0],U,4096336452);V=t(V,Y,X,W,C[P+7],T,1126891415);W=t(W,V,Y,X,C[P+14],R,2878612391);X=t(X,W,V,Y,C[P+5],O,4237533241);Y=t(Y,X,W,V,C[P+12],U,1700485571);V=t(V,Y,X,W,C[P+3],T,2399980690);W=t(W,V,Y,X,C[P+10],R,4293915773);X=t(X,W,V,Y,C[P+1],O,2240044497);Y=t(Y,X,W,V,C[P+8],U,1873313359);V=t(V,Y,X,W,C[P+15],T,4264355552);W=t(W,V,Y,X,C[P+6],R,2734768916);X=t(X,W,V,Y,C[P+13],O,1309151649);Y=t(Y,X,W,V,C[P+4],U,4149444226);V=t(V,Y,X,W,C[P+11],T,3174756917);W=t(W,V,Y,X,C[P+2],R,718787259);X=t(X,W,V,Y,C[P+9],O,3951481745);Y=K(Y,h);X=K(X,E);W=K(W,v);V=K(V,g)}var i=B(Y)+B(X)+B(W)+B(V);return i.toLowerCase()};

			var size = size || 80;

			return 'http://www.gravatar.com/avatar/' + MD5( email ) + '.jpg?s=' + size;
		},

		create_cookie: function( name, value, seconds ) {
			var expires = null;

			var post_arr = $post_content.attr('id').split('-');
			name += '_' + post_arr[2];

			if ( seconds ) {
				var date = new Date();
				date.setTime(date.getTime()+(seconds * 1000));
				expires = "; expires="+date.toGMTString();
			} else {
				expires = "";
			}
			document.cookie = name + "=" + value + expires + "; path=/";
		},

		create_global_cookie: function( name, value, seconds ) {
			if ( seconds ) {
				var date = new Date();
				date.setTime( date.getTime() + (seconds * 1000) );
				var expires = "; expires="+date.toGMTString();
			} else {
				var expires = "";
			}

			document.cookie = name + "=" + value + expires + "; path=/";
		},

		read_cookie: function( name, unique ) {
			if ( unique ) {
				var post_arr = $post_content.attr('id') ? $post_content.attr('id').split('-') : '';
				name += '_' + post_arr[2];
			}

			var nameEQ = name + "=";
			var ca = document.cookie.split(';');
			for ( var i=0; i < ca.length; i++ ) {
				var c = ca[i];
				while ( c.charAt(0)==' ' ) {
					c = c.substring( 1, c.length );
				}

				if ( c.indexOf( nameEQ ) == 0 ) {
					return c.substring( nameEQ.length, c.length );
				}
			}
			return null;
		},

		delete_cookie: function(name, global) {
			if ( global ) {
				methods.create_global_cookie( name, "", -1 );
				return;
			}//end if

			var post_arr = $post_content.attr('id').split('-');
			name += '_' + post_arr[2];
			methods.create_cookie( name, "", -1 );
		},

		check_identity : function( js_method, force_check ) {
			var force = force_check ? force_check : null;
			if ( null === methods.read_cookie('pro-is-logged-in') && null === force ) {
				go_remote_identity.login = {
					nav: {
						url: methods.get_sign_in_url(),
						title: 'Sign in'
					}
				};
				go_remote_identity.identity_checked = true;
				amplify.publish( 'go-auth-not-authenticated' );
				$( document ).trigger( 'go-auth-not-authenticated' );
				return $(this);
			}

			var social_ajax = methods.get_identity_server() + '/wp-admin/admin-ajax.php?action=go_identity&callback=?';
			var xhr = $.ajax({
				url : social_ajax,
				cache : true,
				dataType: 'jsonp'
			});

			xhr.fail( function( j, t, error ) {
				amplify.publish( 'go-auth-fail' );
				$( document ).trigger( 'go-auth-fail' );
				return false;
			});

			xhr.done( function( user_data ) {
				go_remote_identity.identity_checked = true;

				if ( ! user_data || 'undefined' == typeof user_data.display_name || ! user_data.display_name ) {
					amplify.publish( 'go-auth-fail' );
					$( document ).trigger( 'go-auth-fail' );
					return false;
				}//end if

				go_remote_identity.auth_type = methods.auth_type( user_data );
				go_remote_identity.user = user_data;
				go_remote_identity.logged_in_as = user_data.username;

				amplify.publish( 'go-auth-success', user_data );
				$( document ).trigger( 'go-auth-success', user_data );

				if ( 'undefined' == typeof js_method ) {
					return true;
				}

				if ( 'undefined' != typeof methods[ js_method ] ) {
					$(document).GoIdentity( js_method, user_data );
				} else {
					var period_index = js_method.indexOf( '.' );

					if ( -1 == period_index ) {
						// if there isn't a period, call the global function
						js_method( user_data );
					} else {
						// there's a period, call the method (currently only supports methods 1-deep)
						js_method = js_method.split( '.' );
						window[ js_method[0] ][ js_method[1] ]( user_data );
					}//end else
				}

				return true;
			});

			return $(this);
		},

		auth_type : function( user ) {
			var auth_type = null;

			if ( 'undefined' == typeof user.go_oauth_identity ) {
				return auth_type;
			}

			if ( 'undefined' != typeof user.go_oauth_identity.twitter ) {
				auth_type = 'twitter';
			} else if ( 'undefined' != typeof user.go_oauth_identity.linkedin ) {
				auth_type = 'linkedin';
			} else if ( 'undefined' != typeof user.go_oauth_identity.facebook ) {
				auth_type = 'facebook';
			} else if ( 'undefined' != typeof user.go_oauth_identity.gigaom ) {
				auth_type = 'gigaom';
			}

			return auth_type;
		},

		/**
		 * Notify of a reauthentication
		 */
		reauth_notify: function( user ) {
			amplify.publish( 'go-auth-reauth', user );
			$( document ).trigger( 'go-auth-reauth', user );
		}
	};

	/**
	 * Method calling logic
	 * http://docs.jquery.com/Plugins/Authoring
	 * @param methods An array of methods
	 */
	$.fn.GoIdentity = function( method ) {
		if ( methods[method] ) {
			return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || ! method ) {
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on jQuery.GoIdentity' );
		}
	};
})(jQuery); //end GO_Identity SDK
;
( function( $ ) {
	$(document).GoIdentity();
	$(document).GoIdentity( 'check_identity' );
})( jQuery );
;
var go_remote_identity_service = null;
var go_remote_identity_redirect = null;

var go_remote_identity_login = {
	credential_check_url: null,
	lightbox_class: 'go-remote-identity-sign-in-lightbox',
	redirect_url: null,
	event: {},
	popup: null
};

(function( $ ) {
	/**
	 * initializes all the pieces of this object
	 */
	go_remote_identity_login.init = function() {
		amplify.subscribe( 'go-auth-reauth', function() {
			window.location.reload();
		});

		this.credential_check_url = this.get_identity_server() + '/wp-admin/admin-ajax.php',

		$( document ).on( 'click', '.sign-in-link', this.event.sign_in );
		$( document ).on( 'click', '.' + this.lightbox_class + ' a.forgot-password', this.event.forgot_password );
		$( document ).on( 'click', '.' + this.lightbox_class + ' a.why', this.event.why );
		$( document ).on( 'click', '.' + this.lightbox_class + ' a.sign-up', this.event.sign_up );
		$( document ).on( 'click', '.' + this.lightbox_class + ' .social li a', this.event.social );

		// Display the sign in lightbox by if the #sign-in hash is present
		if ( '#sign-in' == window.location.hash ) {
			go_remote_identity_login.init_sign_in();
		} // END if
	};

	/**
	 * get identity_server
	 */
	go_remote_identity_login.get_identity_server = function() {
		var server = go_remote_identity_data.identity_server;

		server = server.replace( /https?:/, '' );
		server = document.location.protocol + server;

		return server;
	};

	/**
	 * shifts the lightbox to show the forgot password form
	 */
	go_remote_identity_login.show_forgot_password = function() {
		var $colorbox = $('#colorbox');
		$colorbox.addClass( 'forgot-password' );
		$.colorbox.resize();
		$colorbox.find( 'input:visible:first' ).focus();
	};

	/**
	 * shows the sign up form
	 */
	go_remote_identity_login.show_sign_up = function() {
		var $colorbox = $('#colorbox');
		$colorbox.removeClass( this.lightbox_class );
		$colorbox.removeClass('forgot-password');
		$colorbox.removeClass('logging-in');
	};

	/**
	 * shows the sign in form
	 */
	go_remote_identity_login.show_sign_in = function() {
		var $colorbox = $('#colorbox');
		$colorbox.addClass( this.lightbox_class );
		$colorbox.removeClass('forgot-password');
		$colorbox.removeClass('logging-in');
		$.colorbox.resize();
	};

	/**
	 * initializes the sign-in lightbox
	 */
	go_remote_identity_login.init_sign_in = function() {
		var window_width = $(window).width();

		window_width = window_width <= 390 ? window_width : 390;

		$.colorbox({
			html: $( '#go-remote-identity-login-form' ).html(),
			close: 'x',
			maxWidth: 390,
			width: window_width,
			open: true,
			overlayClose: true,
			scrolling: false,
			title: ' ',
			onLoad: function() {
				var $colorbox = $('#colorbox');
				$colorbox.addClass( go_remote_identity_login.lightbox_class );
				$( '#cboxClose' ).html( '<i class="goicon icon-x"></i>' );
			},
			onClosed: function() {
				var $colorbox = $('#colorbox');
				$colorbox.removeClass( go_remote_identity_login.lightbox_class );
				$colorbox.removeClass('forgot-password');
				$colorbox.removeClass('logging-in');
			},
			onComplete : function() {
				$( '#colorbox' ).find( 'input:visible:first' ).focus();
				// make sure the ids/for attributes on labels/input
				$('.' + go_remote_identity_login.lightbox_class ).find('label').each( function() {
					var $parent = $(this).closest( 'li' );
					var $input = $parent.find( 'input' );

					if ( ! $input.length ) {
						return;
					}//end if

					var the_id = $input.attr('id');
					the_id = the_id + '-lightbox';

					$input.attr( 'id', the_id );
					$(this).attr( 'for', the_id );
				});

				$(this).colorbox.resize();
			}
		});
	};

	/**
	 * toggles the "why" details on the sign in lightbox
	 */
	go_remote_identity_login.toggle_why_details = function() {
		var $details = $('.why-details');

		if ( $details.is( ':visible' ) ) {
			$details.hide();
		} else {
			$details.show();
		}//end else

		$(this).colorbox.resize();
	};

	/**
	 * reacts to the social credential check and either redirects or re-shows the sign in box
	 */
	go_remote_identity_login.react_to_credential_check = function( data ) {
		// if the popup is still open, don't do anything yet
		if ( ! go_remote_identity_login.popup.closed ) {
			return;
		}//end if

		if ( 'undefined' == typeof data.authed || ! data.authed ) {
			this.show_sign_in();
			return;
		}

		window.location = this.redirect_url;
	};

	/**
	 * handles the clicking of the "forgot password" link on the sign in lightbox
	 */
	go_remote_identity_login.event.forgot_password = function( e ) {
		e.preventDefault();
		go_remote_identity_login.show_forgot_password();
	};

	/**
	 * handles the clicking of the "why" link on the sign in lightbox
	 */
	go_remote_identity_login.event.why = function( e ) {
		e.preventDefault();
		go_remote_identity_login.toggle_why_details();
	};

	/**
	 * handles the clicking of the "sign up" link on the sign in lightbox
	 */
	go_remote_identity_login.event.sign_up = function( e ) {
		e.preventDefault();
		go_remote_identity_login.show_sign_up();
	};

	/**
	 * handles the clicking of "sign in" links
	 */
	go_remote_identity_login.event.sign_in = function( e ) {
		e.preventDefault();
		go_remote_identity_login.init_sign_in();
	};

	/**
	 * handles the clicking of a social sign-in link on the sign in lightbox
	 */
	go_remote_identity_login.event.social = function( e ) {
		e.preventDefault();

		var $colorbox = $('#colorbox');

		$colorbox.addClass( 'logging-in' );
		$(this).colorbox.resize();

		var $el = $(this);
		var url = $el.attr('href');
		var $parent = $el.closest('li');

		var width = 800;
		var parent_class = $parent.attr('class');
		go_remote_identity_service = parent_class;
		go_remote_identity_login.popup = window.open( url, parent_class, 'resizeable=1,width=' + width + ',height=480' );

		var timer = setInterval( function() {
			var query_vars = [];
			var hash = null;

			if ( null !== go_remote_identity_login.popup ) {
				if ( go_remote_identity_login.popup.location && ! go_remote_identity_login.popup.closed ) {
					var hashes = go_remote_identity_login.popup.location.search.slice( go_remote_identity_login.popup.location.search.indexOf( '?' ) + 1 ).split( '&' );
					for ( var i = 0, length = hashes.length; i < length; i++ )
					{
						hash = hashes[ i ].split( '=' );
						query_vars.push( hash[0] );
						query_vars[ hash[0] ] = hash[1];
					}//end for
				}//end if

				var server = go_remote_identity_data.identity_server.replace( /https?:\/\//, '' );

				go_remote_identity_login.redirect_url = 'https://' + server +
					'/subscription/sign-in/?goauth_message=1&goauth_service=' +
					go_remote_identity_service +
					'&goauth_action=login_connect' +
					'&redirect_to=' +
					encodeURIComponent(
						'/subscription/sign-in/?goauth_service=' +
						go_remote_identity_service +
						'&goauth_action=login_connect&loc=' + encodeURIComponent( window.location.href )
					);

				if ( go_remote_identity_login.popup.closed ) {
					window.focus();
					clearInterval( timer );

					var xhr = $.ajax({
						url: go_remote_identity_login.credential_check_url,
						dataType: 'jsonp',
						data: {
							action: 'go_identity_social_credentials',
							callback: 'go_remote_identity_login.react_to_credential_check',
							goauth_service: go_remote_identity_service
						}
					});
				}//end if
			}//end if
		}, 250);
	};
})( jQuery );

jQuery(function( $ ) {
	go_remote_identity_login.init();
});
;
/**
 * Recurring, pausable timer
 * from: http://jsfiddle.net/timdown/Hkzex/
 */
function RecurringTimer( callback, delay ) {
    var timer_id = false;
    var start, remaining = delay;

    this.pause = function() {
    	if ( ! timer_id ) {
    		return;
    	}// end if

        window.clearTimeout( timer_id );
        timer_id = false;
        remaining -= new Date() - start;
    };

    var resume = function() {
        if ( timer_id ) {
        	return;
        }// end if

		start = new Date();
		timer_id = window.setTimeout( function() {
			remaining = delay;
			timer_id = false;
			resume();
			callback();
		}, remaining );
    };

    this.resume = resume;
}// end RecurringTimer;
/**
 * author Remy Sharp
 * url http://remysharp.com/2009/01/26/element-in-view-event-plugin/
 */
(function ($) {
    function getViewportHeight() {
        var height = window.innerHeight; // Safari, Opera
        var mode = document.compatMode;

        if ( (mode || !$.support.boxModel) ) { // IE, Gecko
            height = (mode == 'CSS1Compat') ?
            document.documentElement.clientHeight : // Standards
            document.body.clientHeight; // Quirks
        }

        return height;
    }

    $(window).scroll(function () {
        var vpH = getViewportHeight(),
            scrolltop = (document.documentElement.scrollTop ?
                document.documentElement.scrollTop :
                document.body.scrollTop),
            elems = [];
        
        // naughty, but this is how it knows which elements to check for
        $.each($.cache, function () {
            if (this.events && this.events.inview) {
                elems.push(this.handle.elem);
            }
        });

        if (elems.length) {
            $(elems).each(function () {
                var $el = $(this),
                    top = $el.offset().top,
                    height = $el.height(),
                    inview = $el.data('inview') || false;

                if (scrolltop > (top + height) || scrolltop + vpH < top) {
                    if (inview) {
                        $el.data('inview', false);
                        $el.trigger('inview', [ false ]);                        
                    }
                } else if (scrolltop < (top + height)) {
                    if (!inview) {
                        $el.data('inview', true);
                        $el.trigger('inview', [ true ]);
                    }
                }
            });
        }
    });
    
    // kick the event to pick up any elements already in view.
    // note however, this only works if the plugin is included after the elements are bound to 'inview'
    $(function () {
        $(window).scroll();
    });
})(jQuery);
;
if ( typeof gigaom == 'undefined' ) {
	var gigaom = {};
}//end if

gigaom.events = {
	articles: {},
	notify_posts: [],
	data: {}
};

( function( $ ) {
	"use strict";

	gigaom.events.notify_cookie_id = 'go_events_navigation';

	gigaom.events.init = function() {
		// register a new sidepanel
		gigaom.nav.panels.events = {
			name: 'events',
			direction: 'right',
			control: 'body:not(.go-device-full) .nav-events a'
		};

		gigaom.nav.init_sidepanel( 'events' );

		gigaom.events.$nav_events = gigaom.$nav.find('.nav-events');
		gigaom.events.$control = gigaom.$nav.find('.control-events');
		gigaom.events.$notification = gigaom.events.$control.find('.notification');

		gigaom.events.cookie = gigaom.events.get_cookie( gigaom.events.notify_cookie_id );

		// we need the utc_timestamp. Let's calc it once and store it
		var date_current            = new Date();
		var date_utc                = new Date( date_current.getUTCFullYear(), date_current.getUTCMonth(), date_current.getUTCDate(), date_current.getUTCHours(), date_current.getUTCMinutes(), date_current.getUTCSeconds() );
		gigaom.events.utc_timestamp = Math.floor( date_utc.getTime() / 1000 );

		amplify.request.define('load_articles', 'ajax', {
			url: go_events_endpoint_url,
			dataType: 'jsonp',
			type: 'GET',
			cache: 15000
		});

		// subscribe to interactions with the nav control
		amplify.subscribe( 'go-nav-control-open', gigaom.events.go_nav_control_open );
		amplify.request( 'load_articles', gigaom.events.load_articles );

		$(document).on( 'click', '.e-to-top', function( e ) {
			e.preventDefault();
			$('html,body').animate({ scrollTop: 0 }, 600, function() {
				if ( gigaom.$html_body.hasClass('go-device-full') ) {
					$('#go-theme-nav .nav-events').mouseover();
				} else {
					gigaom.nav.toggle( 'events', 'right' );
				}//end else
			});
		});
	};

	gigaom.events.load_articles = function( data ) {
		var template              = $('#event-post-tpl').html();
		var $events               = $('.nav-events');
		var $sidepanel            = $('.sidepanel.events');

		var utm = {
			utm_source: gigaom.channel,
			utm_medium: 'nav',
			utm_campaign: 'events-nav'
		};

		gigaom.events.sections = {
			conference: {
				$container: $events.find('.conferences'),
				$side_container: $sidepanel.find('.conferences')
			},
			webinar: {
				$container: $events.find('.webinars'),
				$side_container: $sidepanel.find('.webinars')
			},
			editorial: {
				$container: $events.find('.editorial'),
				$side_container: $sidepanel.find('.editorial')
			},
			meetup: {
				$container: $events.find('.meetups'),
				$side_container: $sidepanel.find('.meetups')
			}
		};

		gigaom.events.data = data;

		// compile articles into HTML
		for ( var id in data ) {
			// set the content for the UTM
			utm.utm_content = data[ id ].encoded_title;

			// construct a query string from the utm object
			var utm_query_string = $.param( utm );

			// append utm data onto URL
			if ( data[ id ].url.indexOf( '?' ) >= 0 ) {
				data[ id ].url += '&' + utm_query_string;
			} else {
				data[ id ].url += '?' + utm_query_string;
			}//end else

			data[ id ].compiled = $.mustache( template, data[ id ] );

			gigaom.events.sections[ data[ id ].event_type ].$container.append( data[ id ].compiled );
			gigaom.events.sections[ data[ id ].event_type ].$side_container.append( data[ id ].compiled );

			gigaom.events.maybe_queue_notify( data, id );
		}//end for

		// if set a class to indicate sections should be shown if they contain
		// articles
		for ( var section in gigaom.events.sections ) {
			if ( gigaom.events.sections[ section ].$container.find('.event').length ) {
				$events.addClass( 'has-' + section );
				$sidepanel.addClass( 'has-' + section );
			}//end if
		}//end for

		amplify.publish( 'go-event-navigation-events-loaded' );

		// show the number on the icon
		gigaom.events.notify();
	};

	gigaom.events.maybe_queue_notify = function( data, id ) {
		var event_state_is_recent = ( data[ id ].state.timestamp + 432000 ) >= gigaom.events.utc_timestamp;
		var exists = false;
		var is_new = false;

		if ( 'new' === data[ id ].state.type && event_state_is_recent ) {
			exists = gigaom.events.cookie.hasOwnProperty( id );

			if ( ! exists || ( exists && gigaom.events.cookie[ id ].timestamp < data[ id ].state.timestamp ) ) {
				gigaom.events.notify_posts.push( data[ id ] );
				is_new = true;
			}//end if
		}//end if

		if ( ! is_new ) {
			$('.' + id ).removeClass('new');
		}//end if
	};

	/**
	 * notify the user of something
	 */
	gigaom.events.notify = function() {
		if ( ! gigaom.events.notify_posts.length ) {
			return;
		}//end if

		gigaom.events.$notification.html( gigaom.events.notify_posts.length );
		gigaom.events.$nav_events.addClass('notify');
	};

	gigaom.events.set_cookie = function( cookie_id, data ) {
		$.cookie( cookie_id, JSON.stringify( data ), {
			expires: 365,
			path: '/'
		});
	};

	gigaom.events.get_cookie = function( cookie_id ) {
		var cookie = $.cookie( cookie_id );

		if ( ! cookie ) {
			return {};
		}//end if

		return JSON.parse( cookie );
	};

	/**
	 * if the events nav item opens, remove the notification
	 */
	gigaom.events.go_nav_control_open = function( panel ) {
		if ( 'events' === panel ) {
			gigaom.events.$nav_events.removeClass('notify');
			gigaom.events.set_all_notifications_seen();
		}//end if
	};

	/**
	 * Once a notification has been seen, set the cookie with the right data
	 */
	gigaom.events.set_all_notifications_seen = function() {
		var data = {};

		for ( var i in gigaom.events.data ) {
			data[ i ] = gigaom.events.data[ i ].state;
		}//end for

		gigaom.events.set_cookie( gigaom.events.notify_cookie_id, data );
	};
})( jQuery );

amplify.subscribe( 'go-nav-init', gigaom.events.init );

;
if ( typeof gigaom == 'undefined' ) {
	var gigaom = {};
}//end if

if ( typeof gigaom.events == 'undefined' ) {
	gigaom.events = {};
}//end if

gigaom.events.balloon = {};

( function( $ ) {
	"use strict";

	gigaom.events.balloon.cookie_id = 'go_events_balloon';
	gigaom.events.balloon.count = 0;
	gigaom.events.balloon.max_count = 3; // in seconds

	/**
	 * Setup the balloon
	 */
	gigaom.events.balloon.init = function() {
		if ( gigaom.events.balloon.show() ) {
			gigaom.events.balloon.inflate();

			// create the timer
			gigaom.events.balloon.timer = new RecurringTimer( function() {
				gigaom.events.balloon.count++;

				if ( gigaom.events.balloon.count >= gigaom.events.balloon.max_count ) {
					gigaom.events.balloon.finish();
				}// end if
			}, 1000);

			// start the timer
			gigaom.events.balloon.timer.resume();

			// stop/start the timer when the balloon scrolls out of the viewport
			gigaom.events.$balloon.bind( 'inview', function( event, visible ) {
				if ( true === visible ) {
					gigaom.events.balloon.timer.resume();
				} else {
					gigaom.events.balloon.timer.pause();
				}// end else
			});

			$(document).on( 'mouseover', '.event-balloon', function() {
				gigaom.events.balloon.timer.pause();
			});

			$(document).on( 'mouseout', '.event-balloon', function() {
				gigaom.events.balloon.timer.resume();
			});
		} else {
			gigaom.events.notify();
		}// end else
	};

	gigaom.events.balloon.inflate = function() {
		gigaom.events.$balloon = gigaom.events.balloon.find_event().clone( true );

		if ( ! gigaom.events.$balloon.length ) {
			return;
		}//end if

		// watch for window resizes and resize the balloon accordingly
		amplify.subscribe( 'go-resize-execute', gigaom.events.balloon.resize );

		var $primary_nav = $('#go-theme-nav .header.primary .nav-events');

		// make sure the balloon is hidden and then add it to the DOM
		gigaom.events.$balloon.addClass('event-balloon').css( { visibility: 'hidden' } );
		gigaom.events.$balloon.prependTo( $primary_nav );

		// fix the utm code for the balloon so it tracks appropriately
		var $link = gigaom.events.$balloon.find('header a');
		$link.attr( 'href', $link.attr('href').replace('events-nav', 'events-nav-balloon') );
		$link.attr( 'href', $link.attr('href').replace('events-nav-balloon-balloon', 'events-nav-balloon') );

		// To support balloon resizes, we need to get the max widths of the title and body.
		var $article = gigaom.events.$balloon.clone();

		$article.css({
			bottom: 0,
			display: 'block',
			left: 0,
			margin: 0,
			padding: 0,
			position: 'absolute',
			right: 0,
			top: 0,
			visibility: 'hidden',
			width: 960
		});

		$article.appendTo( $primary_nav );

		// grab the widths
		var title_width = gigaom.events.balloon.element_max_width( $article.find('header') );
		var body_width  = gigaom.events.balloon.element_max_width( $article.find('.body') );
		var max_width   = title_width + body_width + 36;

		$article.remove();

		// if the max width is greater than 960, force 960
		if ( max_width > 960 ) {
			max_width = 960;
		}//end if

		// store the width data in the balloon
		gigaom.events.$balloon.data( 'title-width', title_width );
		gigaom.events.$balloon.data( 'body-width', body_width );
		gigaom.events.$balloon.data( 'max-width', max_width );

		// resize the balloon
		gigaom.events.balloon.resize();

		gigaom.events.$control.append( '<span class="arrow"></span>' );

		// make the balloon clickable
		gigaom.events.$balloon.on( 'click', function( e ) {
			e.preventDefault();

			var href = $(this).find( 'header a' ).attr('href');
			document.location = href;
		});

		// show the balloon
		gigaom.events.$balloon.css( { visibility: 'visible' } );

		amplify.publish( 'go-event-navigation-balloon-inflate' );
	};

	/**
	 * Computing the width of an element within an absolutely position element sucks.
	 * As such, we have to wrap the text of the element with a span, grab the width of
	 * that, then revert.  That's what this function does.
	 */
	gigaom.events.balloon.element_max_width = function( $el ) {
		$el.css({
			display: 'block',
			position: 'absolute',
			width: 960
		});

		var original_html = $el.html();
		var temp_html = '<span>' + original_html + '</span>';

		$el.html( temp_html );

		var width = $el.find('span:first').outerWidth();

		return width;
	};

	/**
	 * resizes the balloon based on viewport width
	 */
	gigaom.events.balloon.resize = function() {
		var available_space = 960;

		if ( ! gigaom.$html_body.is('.go-device-full') ) {
			var control_offset   = gigaom.events.$control.offset();
			var hamburger_offset = $('#nav-toggle').offset();
			var hamburger_width  = $('#nav-toggle').outerWidth();

			// Compute the available space based on the position of the hamburger and control.
			// For full width, the available space will be 0
			available_space  = control_offset.left - hamburger_offset.left - hamburger_width;
		}//end if

		// grab the max with stored in the balloon
		var max_width = gigaom.events.$balloon.data('max-width');

		// Choose the smaller of the two widths
		var new_width = max_width < available_space ? max_width : available_space;

		gigaom.events.$balloon.css( { width: new_width } );
	};

	/**
	 * find the most recent new conference
	 */
	gigaom.events.balloon.find_event = function() {
		var events = gigaom.events.get_cookie( gigaom.events.balloon.cookie_id );

		var $balloon = $();

		gigaom.events.sections.conference.$container.find('.event.new').each( function() {
			var $el = $(this);

			if ( ! $balloon.length && typeof events['conference-' + $el.data('id')] == 'undefined' ) {
				$balloon = $el;
			}//end if
		});

		return $balloon;
	};

	/**
	 * fade out the balloon
	 */
	gigaom.events.balloon.pop = function() {
		var $arrow = gigaom.events.$control.find('.arrow');

		$arrow.fadeOut( 'fast' );
		gigaom.events.$balloon.fadeOut( 'fast' );

		$arrow.promise().done( function() {
			$(this).remove();
		});

		gigaom.events.$balloon.promise().done( function() {
			$(this).remove();
			delete gigaom.events.$balloon;
		});

		// don't listen for resizes anymore
		amplify.unsubscribe( 'go-resize-execute', gigaom.events.balloon.resize );
	};

	/**
	 * should determine if the balloon should be shown based on coookie
	 * @return boolean
	 */
	gigaom.events.balloon.show = function() {
		var $event = gigaom.events.balloon.find_event();

		if ( ! $event.length ) {
			return false;
		}
		return true;
	};

	/**
	 * Should set the cookie and stop the timer
	 */
	gigaom.events.balloon.finish = function() {

		gigaom.events.balloon.timer.pause();

		if ( typeof gigaom.events.$balloon == 'undefined' ) {
			return;
		}// end if

		// set the cookie so it is not seen again
		var index = 'conference-' + gigaom.events.$balloon.data('id');
		var data = gigaom.events.get_cookie( gigaom.events.balloon.cookie_id ) || {};
		data[index] = gigaom.events.data[ index ].state;

		// purge data that's no longer on the page or no longer new
		for ( var i in data ) {
			var $el = $( '.' + i );

			if ( ! $el.length || ! $el.hasClass('new') ) {
				delete data[ i ];
			}//end if
		}//end for

		gigaom.events.set_cookie( gigaom.events.balloon.cookie_id, data );

		// make it disappear in the UI
		gigaom.events.balloon.pop();
	};
})(jQuery);

amplify.subscribe( 'go-event-navigation-events-loaded', gigaom.events.balloon.init );
;
jQuery( function( $ ) {
	amplify.subscribe( 'go-auth-success', function( user ) {
		if ( 'undefined' == typeof user.role ) {
			return;
		}//end if

		var $subscribe_section = $( '#go-theme-nav .nav-subscribe .research .subscription' );
		var $enterprise_section = $( '#go-theme-nav .nav-subscribe .research .enterprise' );

		if ( 'subscriber' == user.role ) {
			$subscribe_section.find( '.prompt' ).hide();
			$subscribe_section.find( '.subscribed' ).show();
		} else if ( 'User-Enterprise' == user.type ) {
			$subscribe_section.hide();

			if ( 'undefined' != typeof user.enterprise_cta ) {
				var $cta = $( user.enterprise_cta ).find( '#go-marketing-cta p' );

				$cta.unwrap();

				var $subscribed = $enterprise_section.find( '.subscribed' );

				$enterprise_section.find( '.prompt' ).hide();
				$subscribed.html( $cta );
				$subscribed.append( '<p><a class="button" href="https://accounts.gigaom.com/my-profile/enterprise/support/">Support</a></p>' );
				$subscribed.show();
			}//end if
		}//end if
	} );
} );
;
if ( 'undefined' === typeof bsocial_comments ) {
	var bsocial_comments = {};
}//end if

if ( 'undefined' === typeof bsocial_comments.event ) {
	bsocial_comments.event = {};
}//end if

( function( $ ) {
	'use strict';

	/**
	 * initializes the bsocial_comments features
	 */
	bsocial_comments.init = function() {
		if ( ! $( '#comment_post_ID' ).length ) {
			return;
		}//end if

		this.states_requested = false;
		this.authenticated_request_filters = [];
		this.authenticated = $( 'body' ).hasClass( 'logged-in' );
		this.post_id = $( '#comment_post_ID' ).val();

		if ( this.authenticated ) {
			this.request_comment_states();
		}

		$( document ).on( 'click', '.comment-fave a', this.event.fave_comment );
		$( document ).on( 'click', '.comment-flag a', this.event.flag_comment );
		$( document ).on( 'click', '.comment-flag-confirm', this.event.confirm_flag_comment );
		$( document ).on( 'submit', '.flag-logged-in form', this.event.confirm_flag_comment );
		$( document ).on( 'click', '.flag-logged-in .cancel', this.event.cancel_confirm_flag_comment );
		$( document ).on( 'change', '.reason', this.event.select_reason );
		$( document ).on( 'keyup', '.reason-description', this.event.select_reason );
	};

	/**
	 * retrieves comment states via Ajax
	 */
	bsocial_comments.request_comment_states = function() {
		// track that states have been requested
		this.states_requested = true;

		var args = {
			dataType: 'json',
			url: this.endpoint,
			data: {
				action: 'bsocial_comments_feedback_states_for_user',
				post_id: this.post_id,
				user: {
					user_id: this.logged_in_as
				},
				nonce: this.nonce
			},
			success: function( response ) {
				if ( ! response.success ) {
					return;
				}//end if

				bsocial_comments.parse_comment_states( response.data );
			}
		};

		this.authenticated_request( args );
	};

	/**
	 * parses comment state JSON and assigns classes to comments where appropriate
	 */
	bsocial_comments.parse_comment_states = function( states ) {
		for ( var comment_id in states ) {
			var $comment = $( '.comment[data-comment-id="' + comment_id + '"]' );

			// if there is comment data for a comment that doesn't exist on the page, don't bother attempting to set the flag/fave states
			if ( ! $comment.length ) {
				continue;
			}//end if

			if ( 'undefined' !== typeof states[ comment_id ].flagged && states[ comment_id ].flagged ) {
				this.set_flag_state( comment_id, 'flag' );
			}//end if

			if ( 'undefined' !== typeof states[ comment_id ].faved && states[ comment_id ].faved ) {
				this.set_fave_state( comment_id, 'fave' );
			}//end if
		}//end for

		$( document ).trigger( 'bsocial-comments-parsed-comment-states' );
	};

	/**
	 * sets a comments fave state
	 */
	bsocial_comments.set_fave_state = function( comment_id, state ) {
		var $comment = $( '.comment[data-comment-id="' + comment_id + '"]' );

		if ( ! $comment.length ) {
			return;
		}//end if

		var $fave_link = $comment.find( ' > .div-comment .comment-fave a' );
		var href = $fave_link.attr( 'href' );

		$comment.attr( 'data-comment-fave', state );
		$comment.removeClass( 'faving' );

		if ( 'fave' === state ) {
			$fave_link.attr( 'title', 'Unfave this comment' );
			$fave_link.attr( 'href', href.replace( 'direction=fave', 'direction=unfave' ) );
		} else {
			$fave_link.attr( 'title', 'Fave this comment' );
			$fave_link.attr( 'href', href.replace( 'direction=unfave', 'direction=fave' ) );
		}//end else
	};

	/**
	 * sets a comments flag state
	 */
	bsocial_comments.set_flag_state = function( comment_id, state ) {
		var $comment = $( '.comment[data-comment-id="' + comment_id + '"]' );

		if ( ! $comment.length ) {
			return;
		}//end if

		var $flag_link = $comment.children( '.div-comment' ).find( '.comment-flag a' );
		var href = $flag_link.attr( 'href' );

		$comment.attr( 'data-comment-flag', state );
		$comment.removeClass( 'flagging' );

		if ( 'flag' === state ) {
			$flag_link.attr( 'title', 'Unflag this comment' );
			$flag_link.attr( 'href', href.replace( 'direction=flag', 'direction=unflag' ) );
		} else {
			$flag_link.attr( 'title', 'Flag this comment' );
			$flag_link.attr( 'href', href.replace( 'direction=unflag', 'direction=flag' ) );
		}//end else
	};

	/**
	 * handles the interaction with a comment fave link
	 */
	bsocial_comments.fave_comment = function( $link ) {
		var $comment = $link.closest( '.comment' );
		var $feedback_box = $comment.find( '.feedback-box .fave-logged-out' ).filter( ':visible' );

		if ( $feedback_box.length ) {
			$comment.removeClass( 'faving flagging' );
			$comment.find( '.feedback-box' ).slideUp( 'fast' );
			return;
		}//end if

		var args = this.generate_ajax_args( $comment, $link, 'fave' );

		if ( ! this.authenticated ) {
			$comment.addClass( 'faving' ).removeClass( 'flagging' );
			$comment.find( '.feedback-box:first' ).attr( 'data-type', 'fave-logged-out' ).slideDown( 'fast' );
			$( document ).trigger( 'bsocial-comments-defer-action-for-auth', [ args, 'fave' ] );
			$( document ).trigger( 'bsocial-comments-fave-not-authenticated', [ $comment ] );
			return;
		}//end if

		$comment.removeClass( 'faving flagging' );
		this.authenticated_request( args );

		// let's give immediate feedback so we don't have to wait for the ajax round-trip
		this.adjust_fave_count( $comment, 'fave' === $comment.attr( 'data-comment-fave' ) ? 'decrement' : 'increment' );
	};

	/**
	 * increment/decrement fave count
	 */
	bsocial_comments.adjust_fave_count = function( $comment, which ) {
		which = 'decrement' === which ? 'decrement' : 'increment';

		var $fave_count = $comment.find( '.fave-count:first' );
		var count = parseInt( $fave_count.attr( 'data-count' ), 10 );

		if ( 'decrement' === which && count > 0 ) {
			count--;
		} else {
			count++;
		}//end if

		$fave_count.html( count ).attr( 'data-count', count );

		if ( 'fave' === $comment.attr( 'data-comment-fave' ) ) {
			this.set_fave_state( $comment.data( 'comment-id' ), 'unfave' );
		} else {
			this.set_fave_state( $comment.data( 'comment-id' ), 'fave' );
		}//end else
	};

	/**
	 * handles the interaction with a comment flag link
	 */
	bsocial_comments.flag_comment = function( $link ) {
		var $comment = $link.closest( '.comment' );
		var $feedback_box = $comment.find( '.feedback-box' ).filter( ':visible' );

		if ( $feedback_box.find( '.flag-logged-in' ).filter( ':visible' ).length ) {
			$feedback_box.find( '.flag-logged-in .cancel' ).click();
			return;
		}//end if
		else if ( $feedback_box.find( '.flag-logged-out' ).filter( ':visible' ).length ) {
			$comment.removeClass( 'faving flagging' );
			$feedback_box.slideUp( 'fast' );
			return;
		}//end else if

		if ( ! this.authenticated ) {
			$comment.addClass( 'flagging' ).removeClass( 'faving' );
			$comment.find( '.feedback-box:first' ).attr( 'data-type', 'flag-logged-out' ).slideDown( 'fast' );
			var args = this.generate_ajax_args( $comment, $link, 'flag' );
			$( document ).trigger( 'bsocial-comments-defer-action-for-auth', [ args, 'flag' ] );
			$( document ).trigger( 'bsocial-comments-flag-not-authenticated', [ $comment ] );
			return;
		}//end if
		else {
			if ( 'flag' !== $comment.attr( 'data-comment-flag' ) ) {
				$comment.addClass( 'flagging' ).removeClass( 'faving' );
				$comment.find( '.feedback-box:first' ).attr( 'data-type', 'flag-logged-in' ).slideDown( 'fast' );
				$( document ).trigger( 'bsocial-comments-flag-is-authenticated', [ $comment ] );
			} else {
				this.confirm_flag_comment( $link );
			}//end else
		}//end else
	};

	/**
	 * handles the interaction with a comment flag confirmation link
	 */
	bsocial_comments.confirm_flag_comment = function( $link ) {
		var $comment = $link.closest( '.comment' );
		var $form = $comment.find( '> .feedback-box .flag-logged-in' );
		if( 'other' !== $form.find( '.reason:checked' ).data( 'reason-type' ) ) {
			//clear the textarea if we're not submitting "other"
			$form.find( 'textarea' ).val( '' );
		}//end if

		var args = this.generate_ajax_args( $comment, $link, 'flag' );

		if ( ! this.authenticated ) {
			return;
		}//end if

		// if we are flagging a comment AND it is the "Other" option, make sure a description has been entered
		if ( 'flag' !== $comment.attr( 'data-comment-flag' ) && $form.filter( '[data-selected-reason="other"]' ).length ) {
			if ( '' === $.trim( $form.find( '.reason-description' ).val() ) ) {
				$form.find( '.required' ).show();
				return;
			}//end if
		}//end if

		$comment.removeClass( 'faving flagging' );

		this.authenticated_request( args );

		$form.find( '.reason:checked' ).prop( false );
		$form.find( '.reason-description' ).val( '' );

		// let's give immediate feedback so we don't have to wait for the ajax round-trip
		$comment.find( '.feedback-box:first' ).attr( 'data-type', '' ).slideUp( 'fast' );
		if ( 'flag' === $comment.attr( 'data-comment-flag' ) ) {
			this.set_flag_state( $comment.attr( 'data-comment-id' ), 'unflag' );
		} else {
			this.set_flag_state( $comment.attr( 'data-comment-id' ), 'flag' );
		}//end else
		bsocial_comments.form_reset( $form );

		$( document ).trigger( 'bsocial-comments-flag-confirmed', [ $comment ] );
	};

	bsocial_comments.form_reset = function( $form ) {
		//reset the form ( deselect radio and clear textarea )
		$form.find( 'form' )[0].reset();
		//have to hide the text area - and that is based on the data-selected-reason atribute
		$form.find( 'form' ).attr( 'data-selected-reason', '' );
		//re-disable the button see https://github.com/GigaOM/gigaom/issues/5267
		$form.find( '.comment-flag-confirm' ).prop( { 'disabled': true } );
	};

	/**
	 * generates feedback ajax args
	 */
	bsocial_comments.generate_ajax_args = function( $comment, $trigger, type ) {
		if ( $trigger.is( 'button' ) ) {
			var url = $trigger.closest( 'form' ).attr( 'action' );
		} else {
			var url = $trigger.attr( 'href' );
		}

		var type_inverse = null;

		if ( 'flag' === type ) {
			type_inverse = 'unflag';
		} else {
			type_inverse = 'unfave';
		}//end else

		var has_state = false;

		if ( 'undefined' !== typeof $comment.attr( 'data-comment-' + type ) ) {
			has_state = type === $comment.attr( 'data-comment-' + type );
		}//end else

		var args = {
			dataType: 'json',
			url: url,
			data: {
				action: 'bsocial_comments_comment_feedback',
				comment_id: $comment.data( 'comment-id' ),
				post_id: this.post_id,
				direction: has_state ? type_inverse : type,
				user: {}
			}
		};

		if ( 'flag' === type && 'flag' === args.data.direction ) {
			args.data.flag_type = $comment.find( '> .feedback-box .reason:checked' ).val();
			args.data.flag_text = $comment.find( '> .feedback-box .reason-description' ).val();
		}//end if

		return args;
	};

	bsocial_comments.filter_authenticated_request_args = function( filter, priority ) {
		if ( 'undefined' === typeof this.authenticated_request_filters[ priority ] ) {
			this.authenticated_request_filters[ priority ] = [];
		}//end if

		this.authenticated_request_filters[ priority ].push( filter );
	};

	bsocial_comments.authenticated_request = function( args ) {
		// this.logged_in_as comes from wp_localize_script
		if ( this.logged_in_as ) {
			args.data.user = {
				user_id: parseInt( this.logged_in_as, 10 )
			};
		}//end else

		for ( var priority in this.authenticated_request_filters ) {
			for ( var i in this.authenticated_request_filters[ priority ] ) {
				args = this.authenticated_request_filters[ priority ][ i ]( args );
			}//end for
		}//end for

		$.ajax( args );
	};

	bsocial_comments.event.select_reason = function( e ) {
		e.preventDefault();
		var $el = $( this );

		var $flag_button = $el.closest( 'form' ).find( '.comment-flag-confirm' );

		if ( $el.is( ':radio' ) ) {
			if ( 'other' === $el.data( 'reason-type' ) && 0 >= $el.closest( 'form' ).find( '.reason-description' ).val().length ) {
				$flag_button.prop( { 'disabled': true } );
			}else {
				$flag_button.prop( { 'disabled': false } );
			}

			$el.closest( 'form' ).attr( 'data-selected-reason', $el.data( 'reason-type' ) );
		} else {
			//if they've typed in the reason textarea, let them pass
			if ( $.trim( $el.val() ).length ) {
				$flag_button.prop( { 'disabled': false } );
			} else {
				$flag_button.prop( { 'disabled': true } );
			}
		}
	};

	bsocial_comments.event.fave_comment = function( e ) {
		e.preventDefault();

		bsocial_comments.fave_comment( $( this ) );
	};

	bsocial_comments.event.flag_comment = function( e ) {
		e.preventDefault();

		bsocial_comments.flag_comment( $( this ) );
	};

	bsocial_comments.event.confirm_flag_comment = function( e ) {
		e.preventDefault();

		bsocial_comments.confirm_flag_comment( $( this ) );
	};

	bsocial_comments.event.cancel_confirm_flag_comment = function( e ) {
		e.preventDefault();

		var $el = $( this );
		var $form = $( this ).closest( '.feedback-box .flag-logged-in' );

		bsocial_comments.form_reset( $form );

		$el.closest( '.comment' ).removeClass( 'faving flagging' );
		$el.closest( '.feedback-box' ).slideUp( 'fast' );
	};

	$( function() {
		bsocial_comments.init();
	});
})( jQuery );
;
jQuery(function($){
	$(document).on( 'click', '.comment-sharing-icons', function ( e ) {
		e.preventDefault();

		var $comment = $(this).closest( '.comment' );
		var $social = $comment.find( '.social:first' );

		if ( $social.is( ':visible' ) ) {
			$social.slideUp( 'fast' );
		} else {
			$social.slideDown( 'fast' );
		}//end else
	});

	var twitter_url_base = 'https://twitter.com/intent/tweet';

/*
Removing this feature, possibly temporarily
See https://github.com/GigaOM/gigaom/issues/3207

This counter to the data we have, and removing it cannot be considered a test because of the number of independent variables.

	$('blockquote:not(.twitter-tweet), .sub-head .excerpt').each( function() {
		var $el = $(this);
		var $paragraphs = $el.find('p');
		var $post = $el.closest('.post');
		var url = twitter_url_base + '?url=' + $post.find('.entry-title a').attr('href');

		var type = 'Quote';
		var max_length = parseInt( go_local_bsocial.quote_max_length, 10 );

		if ( $el.hasClass('excerpt') ) {
			type = 'Excerpt';
		}//end if

		$el.append( tweet_this( url, type, $paragraphs, max_length ) );
	});
*/

	function tweet_this( url, type, $paragraphs, max_length ) {
		var text = '';
		var orig_max_length = max_length;

		$paragraphs.each( function() {
			// use the browser to strip out html from the paragraph
			// by creating a temp HTML element and leveraging DOM properties
			// via: http://stackoverflow.com/a/822486/124581
			var tmp_div = document.createElement('DIV');
			tmp_div.innerHTML = $(this).html();
			var stripped_text = tmp_div.textContent || tmp_div.innerText;

			if ( ( text.length + stripped_text.length ) >= orig_max_length ) {
				max_length = orig_max_length - 4;
			}//end if

			var words = stripped_text.split(' ');

			for( var i in words ) {
				if ( text.length + words[ i ].length + 1 <= max_length + 1 ) {
					if ( $.trim( words[ i ] ) ) {
						text += words[ i ] + ' ';
					}//end if
				} else {
					break;
				}//end else
			}//end for
		});

		var excerpt = 'From @' + go_local_bsocial.twitter_id + ': %22' + $.trim( text );

		if ( max_length !== orig_max_length ) {
			excerpt += '...';
		}//end if

		url += '&amp;text=' + excerpt + '%22';

		return '<div class="social"><a href="' + url +'" title="Tweet this" class="tweet-this"><i class="goicon icon-twitter"></i>tweet this</a></div>';
	}//end tweet_this
});
;
var go_local_bsocial_cta = {
	just_subscribed: false,
	$form: null,
	identity_check_sent: false,
	identity_received: false,
	form_hidden: false
};

( function( $ ) {
	'use strict';

	go_local_bsocial_cta.init = function() {
		amplify.subscribe( 'go-local-bsocial-cta-loaded', this.identity_check );

		amplify.subscribe( 'go-auth-success', this.auth_success );

		amplify.subscribe( 'go-inject-finished', this.inject_finished );

		$( document ).on( 'submit', '.go-local-bsocial-newsletter-form', this.submit );
	};

	/**
	 * handles the identity checking in response to the cta loading
	 */
	go_local_bsocial_cta.identity_check = function() {
		if ( go_local_bsocial_cta.identity_check_sent ) {
			return;
		}//end if

		go_local_bsocial_cta.$subscribe = $( '.go-local-bsocial-newsletter-form' ).closest( '.cta-section-newsletter' );

		$( document ).GoIdentity( 'check_identity' );

		go_local_bsocial_cta.identity_check_sent = true;
	};

	/**
	 * handles the submission of the bSocial Newsletter CTA
	 */
	go_local_bsocial_cta.submit = function( e ) {
		var $el = $( this );

		if ( ! $el.data( 'identity-server' ) ) {
			return true;
		}//end if

		e.preventDefault();

		// if there isn't an email address, return
		if ( ! $.trim( $el.find( 'input[name="email"]' ).val() ) ) {
			return;
		}//end if

		var $blockui_settings_el = $el.closest( '.cta-section-newsletter' ).parent();

		$el.closest( '.cta-section-newsletter' ).block( {
			message: 'Subscribing...',
			css: {
				border: 'none',
				padding: '15px',
				backgroundColor: '#000',
				'-webkit-border-radius': '4px',
				'-moz-border-radius': '4px',
				opacity: $blockui_settings_el.data( 'blockui-opacity' ) || 0.5,
				color: '#fff',
				top: '20px',
				width: '70%'
			},
			overlayCSS: {
				background: $blockui_settings_el.data( 'blockui-overlay-bg' ) || '#fff'
			}
		} );

		var url = $el.data( 'identity-server' ) + '/wp-admin/admin-ajax.php?action=go_newsletter_subscriptions_subscribe';
		url += '&callback=?';

		$.ajax( {
			dataType: 'json',
			url: url,
			data: $el.serialize(),
			success: function( data ) {
				var $newsletter = $el.closest( '.cta-section-newsletter' );

				// traverse up 1 more level so we can find siblings AND children
				var $subscribed = $newsletter.find( '.subscribed' );

				if ( 'undefined' !== typeof data.message.text ) {
					$subscribed.html( '<p>' + data.message.text + '</p>' );
				} else {
					$subscribed.html( '<p>Oops! We\'re having troubles subscribing you from here. Head on over to our <a href="' + $el.data( 'identity-server' ) + '/newsletters/">newsletter form</a> to subscribe!' );
				}//end else

				$subscribed.show();

				// only hide the subscribe form if the message is a success
				if ( 'success' === data.message.type ) {
					$el.hide();
				}//end if

				$newsletter.unblock();
			}
		} );
	};

	/**
	 * when injections finish, this function determines what UI elements to toggle
	 */
	go_local_bsocial_cta.inject_finished = function() {
		// this is in case the injection is slower than the auth request
		if ( go_local_bsocial_cta.form_hidden ) {
			return;
		}//end if

		//check if cookie is set
		if ( document.cookie.indexOf( 'go_local_bsocial_page_view' ) >= 0 ) {
			// check if injectable is in the post
			if ( 0 !== $( '.go-inject-content' ).next().length ) {
				$( '.cta-section-newsletter.injected-form' ).show();
			}//end if
		} else { //end if
			var date = new Date();
			date.setTime( date.getTime() + ( 30 * 24 * 60 * 60 * 1000 ) );// 30 days
			var expires = date.toGMTString();
			document.cookie = 'go_local_bsocial_page_view=yes; path=/; expires=' + expires;
		}//end else
	};

	/**
	 * when authorization is successful, this function parses the user object and
	 * determines what UI elements to toggle
	 */
	go_local_bsocial_cta.auth_success = function( user ) {
		// have we already received an identity? If so, let's not re-run the same logic again
		if ( go_local_bsocial_cta.identity_received ) {
			return;
		}//end if

		go_local_bsocial_cta.identity_received = true;

		var newsletter = user.go_newsletter_subscriptions || {};
		var count = 0;
		var $form = $( '.go-local-bsocial-newsletter-form' );

		// set newsletter email field if we have an email for this user
		if ( '' !== user.user_email ) {
			$form.find( 'input[name="email"]' ).attr( 'value', user.user_email );
		}

		// because the auth object isn't formatted in an ideal way, we have to loop over
		// the newsletter properties and and count the possible valid keys
		for ( var key in newsletter ) {
			if ( 'email' === key || 'messageType' === key ) {
				continue;
			}//end if

			count++;
		}//end for

		if ( count && 'undefined' !== typeof go_local_bsocial_cta.$subscribe ) {
			if ( go_local_bsocial_cta.maybe_just_subscribed ) {
				$form.closest( '.cta-section-newsletter' ).unblock();
				go_local_bsocial_cta.$subscribe.find( '.subscribed' ).html( "<p>Thanks for subscribing! You will receive your first newsletter as soon as it's published.</p>" );
			}//end if

			//hide the form(s) (actually, their containers) if the user is already subscribed
			$form.each( function(){
				var $current_form = $( this );
				var $form_newsletters = $current_form.find('input[ name^="lists" ]');
				var subscribed = false;

				// make sure they are subscribed to at least 1 newsletter listed in the form
				$form_newsletters.each( function() {
					var list = $( this ).val();

					if ( 'undefined' === typeof list ) {
						return;
					}//end if

					var name = $(this ).attr( 'name' ).replace( /^lists\[(.*)\]\[\]/, '$1' );

					if ( newsletter.hasOwnProperty( name ) && newsletter[ name ].hasOwnProperty( list ) ) {
						subscribed = true;
						return;
					}
				});

				if ( ! subscribed ) {
					return;
				}

				go_local_bsocial_cta.form_hidden = true;
				$current_form.hide();
				//hide the inject container if we're hiding an injected form
				if ( $current_form.parent().hasClass( 'injected-form' ) ) {
					$current_form.parent().hide();
				}// end if

				$current_form.addClass( 'already-subscribed' );
				$current_form.closest( '.cta-section-newsletter' ).find( '.subscribed' ).show();
			});
		}//end if
		else if ( go_local_bsocial_cta.maybe_just_subscribed ) {
			window.location = $form.attr( 'action' );
		}//end if

		$( document ).trigger( 'go-local-bsocial-auth-processed' );
	};
})( jQuery );

go_local_bsocial_cta.init();
;
gigaom.gravatar = {};

(function( $ ) {
	'use strict';

	gigaom.gravatar.init = function() {
		$( '.avatar-placeholder' ).waypoint( {
			offset: '75%',
			triggerOnce: true,
			handler: function( direction ) {
				var src = $( this ).attr( 'href' );

				var $img = $( '<img class="avatar avatar-55 photo avatar-default" height="55" width="55">' );
				$img.attr( 'src', src );

				$( this ).replaceWith( $img );
			}
		});
	};

	$(function() {
		gigaom.gravatar.init();
	});
})( jQuery );
;
/*!
 * jQuery Tools v1.2.5 - The missing UI library for the Web
 * 
 * overlay/overlay.js
 * toolbox/toolbox.expose.js
 * tooltip/tooltip.js
 * 
 * NO COPYRIGHTS OR LICENSES. DO WHAT YOU LIKE.
 * 
 * http://flowplayer.org/tools/
 * 
 */
(function(a){a.tools=a.tools||{version:"v1.2.5"},a.tools.overlay={addEffect:function(a,b,d){c[a]=[b,d]},conf:{close:null,closeOnClick:!0,closeOnEsc:!0,closeSpeed:"fast",effect:"default",fixed:!a.browser.msie||a.browser.version>6,left:"center",load:!1,mask:null,oneInstance:!0,speed:"normal",target:null,top:"10%"}};var b=[],c={};a.tools.overlay.addEffect("default",function(b,c){var d=this.getConf(),e=a(window);d.fixed||(b.top+=e.scrollTop(),b.left+=e.scrollLeft()),b.position=d.fixed?"fixed":"absolute",this.getOverlay().css(b).fadeIn(d.speed,c)},function(a){this.getOverlay().fadeOut(this.getConf().closeSpeed,a)});function d(d,e){var f=this,g=d.add(f),h=a(window),i,j,k,l=a.tools.expose&&(e.mask||e.expose),m=Math.random().toString().slice(10);l&&(typeof l=="string"&&(l={color:l}),l.closeOnClick=l.closeOnEsc=!1);var n=e.target||d.attr("rel");j=n?a(n):null||d;if(!j.length)throw"Could not find Overlay: "+n;d&&d.index(j)==-1&&d.click(function(a){f.load(a);return a.preventDefault()}),a.extend(f,{load:function(d){if(f.isOpened())return f;var i=c[e.effect];if(!i)throw"Overlay: cannot find effect : \""+e.effect+"\"";e.oneInstance&&a.each(b,function(){this.close(d)}),d=d||a.Event(),d.type="onBeforeLoad",g.trigger(d);if(d.isDefaultPrevented())return f;k=!0,l&&a(j).expose(l);var n=e.top,o=e.left,p=j.outerWidth({margin:!0}),q=j.outerHeight({margin:!0});typeof n=="string"&&(n=n=="center"?Math.max((h.height()-q)/2,0):parseInt(n,10)/100*h.height()),o=="center"&&(o=Math.max((h.width()-p)/2,0)),i[0].call(f,{top:n,left:o},function(){k&&(d.type="onLoad",g.trigger(d))}),l&&e.closeOnClick&&a.mask.getMask().one("click",f.close),e.closeOnClick&&a(document).bind("click."+m,function(b){a(b.target).parents(j).length||f.close(b)}),e.closeOnEsc&&a(document).bind("keydown."+m,function(a){a.keyCode==27&&f.close(a)});return f},close:function(b){if(!f.isOpened())return f;b=b||a.Event(),b.type="onBeforeClose",g.trigger(b);if(!b.isDefaultPrevented()){k=!1,c[e.effect][1].call(f,function(){b.type="onClose",g.trigger(b)}),a(document).unbind("click."+m).unbind("keydown."+m),l&&a.mask.close();return f}},getOverlay:function(){return j},getTrigger:function(){return d},getClosers:function(){return i},isOpened:function(){return k},getConf:function(){return e}}),a.each("onBeforeLoad,onStart,onLoad,onBeforeClose,onClose".split(","),function(b,c){a.isFunction(e[c])&&a(f).bind(c,e[c]),f[c]=function(b){b&&a(f).bind(c,b);return f}}),i=j.find(e.close||".close"),!i.length&&!e.close&&(i=a("<a class=\"close\"></a>"),j.prepend(i)),i.click(function(a){f.close(a)}),e.load&&f.load()}a.fn.overlay=function(c){var e=this.data("overlay");if(e)return e;a.isFunction(c)&&(c={onBeforeLoad:c}),c=a.extend(!0,{},a.tools.overlay.conf,c),this.each(function(){e=new d(a(this),c),b.push(e),a(this).data("overlay",e)});return c.api?e:this}})(jQuery);
(function(a){a.tools=a.tools||{version:"v1.2.5"};var b;b=a.tools.expose={conf:{maskId:"exposeMask",loadSpeed:"slow",closeSpeed:"fast",closeOnClick:!0,closeOnEsc:!0,zIndex:9998,opacity:.8,startOpacity:0,color:"#fff",onLoad:null,onClose:null}};function c(){if(a.browser.msie){var b=a(document).height(),c=a(window).height();return[window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,b-c<20?c:b]}return[a(document).width(),a(document).height()]}function d(b){if(b)return b.call(a.mask)}var e,f,g,h,i;a.mask={load:function(j,k){if(g)return this;typeof j=="string"&&(j={color:j}),j=j||h,h=j=a.extend(a.extend({},b.conf),j),e=a("#"+j.maskId),e.length||(e=a("<div/>").attr("id",j.maskId),a("body").append(e));var l=c();e.css({position:"absolute",top:0,left:0,width:l[0],height:l[1],display:"none",opacity:j.startOpacity,zIndex:j.zIndex}),j.color&&e.css("backgroundColor",j.color);if(d(j.onBeforeLoad)===!1)return this;j.closeOnEsc&&a(document).bind("keydown.mask",function(b){b.keyCode==27&&a.mask.close(b)}),j.closeOnClick&&e.bind("click.mask",function(b){a.mask.close(b)}),a(window).bind("resize.mask",function(){a.mask.fit()}),k&&k.length&&(i=k.eq(0).css("zIndex"),a.each(k,function(){var b=a(this);/relative|absolute|fixed/i.test(b.css("position"))||b.css("position","relative")}),f=k.css({zIndex:Math.max(j.zIndex+1,i=="auto"?0:i)})),e.css({display:"block"}).fadeTo(j.loadSpeed,j.opacity,function(){a.mask.fit(),d(j.onLoad),g="full"}),g=!0;return this},close:function(){if(g){if(d(h.onBeforeClose)===!1)return this;e.fadeOut(h.closeSpeed,function(){d(h.onClose),f&&f.css({zIndex:i}),g=!1}),a(document).unbind("keydown.mask"),e.unbind("click.mask"),a(window).unbind("resize.mask")}return this},fit:function(){if(g){var a=c();e.css({width:a[0],height:a[1]})}},getMask:function(){return e},isLoaded:function(a){return a?g=="full":g},getConf:function(){return h},getExposed:function(){return f}},a.fn.mask=function(b){a.mask.load(b);return this},a.fn.expose=function(b){a.mask.load(b,this);return this}})(jQuery);
(function(a){a.tools=a.tools||{version:"v1.2.5"},a.tools.tooltip={conf:{effect:"toggle",fadeOutSpeed:"fast",predelay:0,delay:30,opacity:1,tip:0,position:["top","center"],offset:[0,0],relative:!1,cancelDefault:!0,events:{def:"mouseenter,mouseleave",input:"focus,blur",widget:"focus mouseenter,blur mouseleave",tooltip:"mouseenter,mouseleave"},layout:"<div/>",tipClass:"tooltip"},addEffect:function(a,c,d){b[a]=[c,d]}};var b={toggle:[function(a){var b=this.getConf(),c=this.getTip(),d=b.opacity;d<1&&c.css({opacity:d}),c.show(),a.call()},function(a){this.getTip().hide(),a.call()}],fade:[function(a){var b=this.getConf();this.getTip().fadeTo(b.fadeInSpeed,b.opacity,a)},function(a){this.getTip().fadeOut(this.getConf().fadeOutSpeed,a)}]};function c(b,c,d){var e=d.relative?b.position().top:b.offset().top,f=d.relative?b.position().left:b.offset().left,g=d.position[0];e-=c.outerHeight()-d.offset[0],f+=b.outerWidth()+d.offset[1],/iPad/i.test(navigator.userAgent)&&(e-=a(window).scrollTop());var h=c.outerHeight()+b.outerHeight();g=="center"&&(e+=h/2),g=="bottom"&&(e+=h),g=d.position[1];var i=c.outerWidth()+b.outerWidth();g=="center"&&(f-=i/2),g=="left"&&(f-=i);return{top:e,left:f}}function d(d,e){var f=this,g=d.add(f),h,i=0,j=0,k=d.attr("title"),l=d.attr("data-tooltip"),m=b[e.effect],n,o=d.is(":input"),p=o&&d.is(":checkbox, :radio, select, :button, :submit"),q=d.attr("type"),r=e.events[q]||e.events[o?p?"widget":"input":"def"];if(!m)throw"Nonexistent effect \""+e.effect+"\"";r=r.split(/,\s*/);if(r.length!=2)throw"Tooltip: bad events configuration for "+q;d.bind(r[0],function(a){clearTimeout(i),e.predelay?j=setTimeout(function(){f.show(a)},e.predelay):f.show(a)}).bind(r[1],function(a){clearTimeout(j),e.delay?i=setTimeout(function(){f.hide(a)},e.delay):f.hide(a)}),k&&e.cancelDefault&&(d.removeAttr("title"),d.data("title",k)),a.extend(f,{show:function(b){if(!h){l?h=a(l):e.tip?h=a(e.tip).eq(0):k?h=a(e.layout).addClass(e.tipClass).appendTo(document.body).hide().append(k):(h=d.next(),h.length||(h=d.parent().next()));if(!h.length)throw"Cannot find tooltip for "+d}if(f.isShown())return f;h.stop(!0,!0);var o=c(d,h,e);e.tip&&h.html(d.data("title")),b=b||a.Event(),b.type="onBeforeShow",g.trigger(b,[o]);if(b.isDefaultPrevented())return f;o=c(d,h,e),h.css({position:"absolute",top:o.top,left:o.left}),n=!0,m[0].call(f,function(){b.type="onShow",n="full",g.trigger(b)});var p=e.events.tooltip.split(/,\s*/);h.data("__set")||(h.bind(p[0],function(){clearTimeout(i),clearTimeout(j)}),p[1]&&!d.is("input:not(:checkbox, :radio), textarea")&&h.bind(p[1],function(a){a.relatedTarget!=d[0]&&d.trigger(r[1].split(" ")[0])}),h.data("__set",!0));return f},hide:function(c){if(!h||!f.isShown())return f;c=c||a.Event(),c.type="onBeforeHide",g.trigger(c);if(!c.isDefaultPrevented()){n=!1,b[e.effect][1].call(f,function(){c.type="onHide",g.trigger(c)});return f}},isShown:function(a){return a?n=="full":n},getConf:function(){return e},getTip:function(){return h},getTrigger:function(){return d}}),a.each("onHide,onBeforeShow,onShow,onBeforeHide".split(","),function(b,c){a.isFunction(e[c])&&a(f).bind(c,e[c]),f[c]=function(b){b&&a(f).bind(c,b);return f}})}a.fn.tooltip=function(b){var c=this.data("tooltip");if(c)return c;b=a.extend(!0,{},a.tools.tooltip.conf,b),typeof b.position=="string"&&(b.position=b.position.split(/,?\s/)),this.each(function(){c=new d(a(this),b),a(this).data("tooltip",c)});return b.api?c:this}})(jQuery);
;
if ( 'undefined' === typeof go_socialcomments ) {
	var go_socialcomments = {};
}//end if

go_socialcomments.event = {};

(function($) {
	'use strict';

	/**
	 * Initialize the go_social_comments plugin
	 */
	go_socialcomments.init = function() {
		go_socialcomments.$comment_form = $( '#commentform' );

		// Make sure there's actually a comment form in the page
		if ( 0 === go_socialcomments.$comment_form.length ) {
			return;
		}

		// Clear the identity cookie if the user is logged into their WP account
		if ( $( 'body' ).hasClass( 'logged-in' ) ) {
			$.removeCookie( 'go-socialcomments-identity', { path: '/' } );
		}

		// Clear the comment cookie if there is a get var indicating a comment was submitted
		if ( -1 < window.location.search.indexOf( 'go_commented' ) ) {
			$.removeCookie( 'go-socialcomments-comment' );
		}

		// If we've got a cookie with authorization info we use that
		if ( 'undefined' !== typeof $.cookie( 'go-socialcomments-identity' ) ) {
			go_socialcomments.user = JSON.parse( $.cookie( 'go-socialcomments-identity' ) );
		}

		// Watch social links and do popups when appropriate
		$(document).on( 'click', '.credential-social li a:not(.goauth-wpdotcom)', go_socialcomments.social_popups );

		// Watch featured reply links
		$(document).on( 'click', '.featured-comment-reply-link', go_socialcomments.click_reply );

		$( document ).on( 'go-auth-success', function( event, user ) {
			go_socialcomments.setup_identity( user );
			go_socialcomments.prep_form();
		});

		go_socialcomments.prep_form();

		//move the key question above the ad
		$( '#go-local-bsocial-key-question' ).prev( '.widget-go-inject' ).before( $( '#go-local-bsocial-key-question' ) );

		// Watch functions for comment form
		go_socialcomments.handle_logout();
		go_socialcomments.watch_textarea();
		go_socialcomments.watch_for_guest();
		go_socialcomments.watch_guest_fields();
		go_socialcomments.watch_for_submit();
		go_socialcomments.twiddle_flags();

		$(document).on( 'click', '.cancel-reply', this.event.reply_cancel );
		$(document).on( 'click', '.comment-reply-link', this.event.reply );
	};

	/**
	 * This wraps some words with a span in the flag text so they can be styled differently
	 */
	go_socialcomments.twiddle_flags = function() {
		$( '.comment-flags .flag-details' ).each( function() {
			var $el = $( this );
			var $p = $el.find( 'p:first' );

			var regex = /^([\w ]+\:)/;
			var result = regex.exec( $p.html() );

			if ( ! result ) {
				$p.html( '<span>' + $p.html() + '</span>' );
				return;
			}//end if

			$p.html( $p.html().replace( /^([\w ]+\:)/, '<span>$1</span>' ) );
		});
	};

	/**
	 * Logout from accounts via an AJAX request
	 */
	go_socialcomments.handle_logout = function() {
		// Remove the identity cookie whenever the user explicity logs out
		$(document).on( 'click', '#social-identity-logout a, .logout a', function( event ) {
			$.removeCookie( 'go-socialcomments-identity', { path: '/' } );

			// If this wasn't a wordpress login we'll logout via a hidden iframe and then refresh the page when we know it's gone through
			if ( 'wordpress' !== go_socialcomments.user.service ) {
				event.preventDefault();

				var $iframe = $( '<iframe />' );

				$iframe.attr( 'id', 'goauth-logout' ).hide().appendTo( 'body' );
				$iframe.attr( 'sandbox', 'allow-same-origin' );
				$iframe.attr( 'src', $(this).attr( 'href' ) );

				$(this).replaceWith( '<span>Please wait...</span>' );

				// Once the iframe has loaded the user is logged out so we can refresh the page
				$( '#goauth-logout' ).load(function() {
				    window.location.reload();
				});
			}
		} );
	};

	/**
	 * Determine the identity of the current user if possible
	 */
	go_socialcomments.check_identity = function( user ) {
		// Check for go_remote_identity stuff if it's there we'll override this stuff
		if ( '' !== go_remote_identity.logged_in_as ) {
			go_socialcomments.setup_identity( user );
		}
	};

	/**
	 * sets up a socialcomment identity
	 */
	go_socialcomments.setup_identity = function( user ) {
		// Don't setup identity if the user is logged in via WP
		if ( $( 'body' ).hasClass( 'logged-in' ) ) {
			return;
		}

		go_socialcomments.user.service   = go_remote_identity.auth_type;
		go_socialcomments.user.full_name = '' !== go_remote_identity.user.display_name ? go_remote_identity.user.display_name : go_remote_identity.logged_in_as;
		go_socialcomments.user.email     = user.user_email;
		go_socialcomments.user.avatar    = user.avatar;
		go_socialcomments.user.logout    = social_identity_server + '/wp-admin/admin-ajax.php?action=logout&redirect_to=' + escape( go_theme.wp_url + '/wp-admin/admin-ajax.php' );

		if ( 'twitter' === go_socialcomments.user.service ) {
			go_socialcomments.user.twitter_id = user.go_remote_identity.twitter;
			go_socialcomments.user.service_email = go_socialcomments.user.twitter_id + '@twitter.id';
		} // END if

		if ( 'linkedin' === go_socialcomments.user.service ) {
			go_socialcomments.user.linkedin_id = user.go_remote_identity.linkedin;
			go_socialcomments.user.service_email = go_socialcomments.user.linkedin_id + '@linkedin.id';
		} // END if

		if ( 'facebook' === go_socialcomments.user.service ) {
			go_socialcomments.user.facebook_id = user.go_remote_identity.facebook;
			go_socialcomments.user.service_email = go_socialcomments.user.facebook_id + '@facebook.id';
		} // END if

		// If this is a social account login we assign the service_email to the email value
		if ( 'undefined' !== typeof go_socialcomments.user.service_email ) {
			go_socialcomments.user.email = go_socialcomments.user.service_email;
		} // END if

		// Save this to a cookies so we don't have to call for it again
		$.cookie( 'go-socialcomments-identity', JSON.stringify( go_socialcomments.user ), { expires: 60, path: '/' } );
	};

	/**
	 * Handle social login popups
	 */
	go_socialcomments.social_popups = function( event ) {
		event.preventDefault();

		var popup = null;
		var $el   = $(this);
		var url   = $el.attr('href');
		var width = 480;

		if ( $el.hasClass('goauth-facebook') ) {
			width = 880;
		}

		popup = window.open( url, '', 'resizable=1,width=' + width + ',height=480' );

		var timer = setInterval( function() {
			if ( popup && popup.closed ) {
				window.focus();
				clearInterval( timer );
				$(document).GoIdentity( 'check_identity', 'go_socialcomments.check_identity', true );
			}
		}, 1000);
	};

	/**
	 * Click reply link and move user to the form
	 */
	go_socialcomments.click_reply = function( event ) {
		event.preventDefault();

		var id = $(this).closest( '.li-comment' ).data( 'comment-id' );

		$( '#div-comment-' + id + ' .comment-reply-link' ).click();
		$( 'html, body' ).animate( { scrollTop: $( '.comment-reply-form' ).offset().top } );
	};

	/**
	 * Watch textarea for input
	 */
	go_socialcomments.watch_textarea = function() {
		var form_elements = $( '#commentform-elements' );

		$( '#commentform textarea' ).keyup(function() {
			var is_reply = go_socialcomments.$comment_form.closest('.comment-reply-form').length;

			// Check if the value is empty or not
			if ( '' === $(this).val().trim() && ! is_reply ) {
				go_socialcomments.$comment_form.removeClass( 'active' );
 				form_elements.hide();
			} else if ( '' === $(this).val().trim() ) {
				$( '#comment-submit' ).prop( 'disabled', true );
			} else {
				go_socialcomments.$comment_form.addClass( 'active' );

				if ( false === form_elements.is( ':visible' ) ) {
					form_elements.slideDown( 'fast' );
				}

				if ( go_socialcomments.check_comment_fields() ) {
					$( '#comment-submit' ).prop( 'disabled', false );
				}
			}
		});

		// Whenever the textarea content chanes we save the contents
		$( '#commentform textarea' ).change(function() {
			$.removeCookie( 'go-socialcomments-comment' );
			$.cookie( 'go-socialcomments-comment', $( this ).val(), { expires: 60 } );
		});
	};

	/**
	 * Watch for guest commentor
	 */
	go_socialcomments.watch_for_guest = function() {
		$( '#credential-wp a' ).click(function( event ) {
			event.preventDefault();
			$( '#credential-fields' ).slideToggle( 'fast' );
		});
	};

	/**
	 * Watch submissions of the form, allow only when the form is ready
	 */
	go_socialcomments.watch_for_submit = function( event ) {
		$('#commentform').submit(function() {
			if ( ! go_socialcomments.check_comment_fields() ) {
				event.preventDefault();
			}
		});
	};

	/**
	 * Watch name/email fields
	 */
	go_socialcomments.watch_guest_fields = function() {
		$( '#commentform input' ).keyup(function() {
			if ( go_socialcomments.check_comment_fields() ) {
				$( '#comment-submit' ).prop( 'disabled', false );
			} else {
				$( '#comment-submit' ).prop( 'disabled', true );
			}
		});
	};

	/**
	 * Check comment fields for content
	 */
	go_socialcomments.check_comment_fields = function() {
		if ( '' === $( '#commentform #author' ).attr( 'value' ).trim() ) {
			return false;
		}

		if ( '' === $( '#commentform #email' ).attr( 'value' ).trim() ) {
			return false;
		}

		if ( '' === $( '#commentform #comment' ).attr( 'value' ).trim() ) {
			return false;
		}

		return true;
	};

	/**
	 * Is user logged in?
	 */
	go_socialcomments.is_logged_in = function() {
		if ( '' !== go_socialcomments.user.service ) {
			return true;
		}

		return false;
	};

	/**
	 * Prep form for social interactions
	 */
	go_socialcomments.prep_form = function() {
		// Reset these in case the form was moved
		$( '#commentform-elements' ).show();

		// Populate the comment box with the comment stored in the cookie in the event that there was a page reload/redirect
		if ( 'undefined' !== typeof $.cookie( 'go-socialcomments-comment' ) ) {
			$( '#commentform textarea' ).val( $.cookie( 'go-socialcomments-comment' ) );
			// Trigger a keyup so that watch_textarea knows the contents of the textarea have changed
			$( '#commentform textarea' ).keyup();
		}

		var is_reply = go_socialcomments.$comment_form.closest('.comment-reply-form').length;

		// If the comment textarea is empty AND we aren't replying we hide the credential fields
		if ( '' === go_socialcomments.$comment_form.find( 'textarea' ).val().trim() && ! is_reply ) {
			$( '#commentform-elements, #credential-fields' ).hide();
		}

		// Display appropriate stuff based on whether the user is logged in or not
		if ( ! go_socialcomments.is_logged_in() ) {
			// User isn't logged in
			$( '#comment-submit' ).prop( 'disabled', true );
		} else {
			// Set logged in class on the body
			$('body').addClass( 'logged-in-socialcomments' );

			if ( 'undefined' !== typeof go_remote_identity.auth_type && go_remote_identity.auth_type ) {
				$('body').addClass( 'logged-in-social' );
			}//end if

			// User IS logged in
			$( '#comment-submit' ).prop( 'disabled', false );

			// Prep form with user auth info
			go_socialcomments.set_auth_values();

			if ( is_reply ) {
				// If there's no comment text yet we should disable the submit button
				if ( ! go_socialcomments.check_comment_fields() ) {
					$( '#comment-submit' ).prop( 'disabled', true );
				}

				// If the user is replying we focus on the textarea for them
				$( '#commentform textarea' ).focus();
			}
		}

		// Make sure WP knows the user is logged in via go-auth
		if ( go_socialcomments.is_logged_in ) {
			$( '#comment-textarea' ).after( '<input type="hidden" name="goauth" id="goauth" value="1" />' );
		}
	};

	/**
	 * Fill out the user's various auth values in the form
	 */
	go_socialcomments.set_auth_values = function() {
		var service = go_socialcomments.auth_types[ go_socialcomments.user.service ];

		if ( 'research' === go_socialcomments.property && 'wordpress' === go_socialcomments.user.service ) {
			service = 'Gigaom';
		}

		$( '#shared-auth-reply .social-identity-pic img, #shared-auth img' ).attr( 'src', go_socialcomments.user.avatar );
		$( '#social-identity' ).text( go_socialcomments.user.full_name + ',' );
		$( '#shared-auth-reply .social-identity' ).text( go_socialcomments.user.full_name );
		$( '#social-identity-service' ).text( service );

		// The WP service doesn't need to have the logout URL rewritten for it
		if ( 'wordpress' !== go_socialcomments.user.service ) {
			$( '#social-identity-logout a' ).attr( 'href', go_socialcomments.user.logout );
		}

		// Set name field
		$('#author').val( go_socialcomments.user.full_name );

		// Set email field
		$( '#email' ).val( go_socialcomments.user.email );
	};

	/**
	 * remove empty remnants of .comment-reply-form
	 */
	go_socialcomments.remove_empty_reply_form_containers = function() {
		var $form_containers = $( '.comment-reply-form' );

		$form_containers.each( function() {
			var $el = $( this );
			var $parent_ol = $el.closest( '.children' );

			// if the .comment-reply-form is empty, remove it
			if ( $el.is( ':empty' ) ) {
				$el.remove();
			}//end if

			// if the .children ol is empty now, remove it, too
			if ( $parent_ol.is( ':empty' ) ) {
				$parent_ol.remove();
			}//end if
		});
	};

	/**
	 * handles the clicking of the reply link
	 */
	go_socialcomments.event.reply = function( e ) {
			e.preventDefault();

			var $el = $(this);
			var comment_id      = $el.closest( '.comment' ).data( 'comment-id' );
			var comment_author  = $( '#div-comment-' + comment_id + ' .comment-author' ).text();
			var $comment_parent = go_socialcomments.$comment_form.find( '#comment_parent' );

			var $comment_children = $el.closest( '.comment' ).children( '.children' );

			// Save the current position of the form so we can put it back in the right place after.
			if ( 'undefined' === typeof go_socialcomments.event.form_position ) {
				go_socialcomments.event.form_position  = go_socialcomments.$comment_form.closest( '#comment-form-top, #comment-form-bottom' );
			}

			$( '#div-comment-' + comment_id + ' .social-identity-replyee' ).text( comment_author );

			// Remove any old .comment-reply-form li's so they doesn't cause duplicate forms
			$( '.comment-reply-form' ).remove();

			// There are no comment children yet so we need to add the .children ol
			if ( ! $comment_children.length ) {
				$el.closest( '.comment' ).append( '<ol class="children" />' );
				$comment_children = $el.closest( '.comment' ).children( '.children' );
			}//end if

			$comment_children.prepend( '<li class="comment-reply-form" />' );

			// Set the replyee text
			go_socialcomments.$comment_form.find( '.social-identity-replyee' ).text( comment_author );

			// Move the comment form to the .comment-reply-form li
			go_socialcomments.$comment_form.detach().appendTo( $comment_children.find( '.comment-reply-form' ) );
			$comment_parent.val( comment_id );

			// Disable comment form movement
			gigaom.single.pause_comment_waypoints = true;

			// Set some classes so things look right
			$( '#commentform' ).addClass( 'active div-comment' );

			go_socialcomments.remove_empty_reply_form_containers();
			go_socialcomments.prep_form();
	};

	/**
	 * handles the clicking of the cancel reply link
	 */
	go_socialcomments.event.reply_cancel = function( e ) {
		e.preventDefault();

		var $comment_reply = $( this ).closest( '.comment-reply-form' );
		$comment_reply.children().prependTo( go_socialcomments.event.form_position );

		// Set form position back to undefined
		delete go_socialcomments.event.form_position;

		// Enable comment form movement
		gigaom.single.pause_comment_waypoints = false;

		go_socialcomments.$comment_form.removeClass( 'active div-comment' );
		go_socialcomments.remove_empty_reply_form_containers();
		go_socialcomments.prep_form();
	};

	$( function() {
		go_socialcomments.init();
	});
})( jQuery );
;
var addComment={moveForm:function(a,b,c,d){var e,f=this,g=f.I(a),h=f.I(c),i=f.I("cancel-comment-reply-link"),j=f.I("comment_parent"),k=f.I("comment_post_ID");if(g&&h&&i&&j){f.respondId=c,d=d||!1,f.I("wp-temp-form-div")||(e=document.createElement("div"),e.id="wp-temp-form-div",e.style.display="none",h.parentNode.insertBefore(e,h)),g.parentNode.insertBefore(h,g.nextSibling),k&&d&&(k.value=d),j.value=b,i.style.display="",i.onclick=function(){var a=addComment,b=a.I("wp-temp-form-div"),c=a.I(a.respondId);if(b&&c)return a.I("comment_parent").value="0",b.parentNode.insertBefore(c,b),b.parentNode.removeChild(b),this.style.display="none",this.onclick=null,!1};try{f.I("comment").focus()}catch(l){}return!1}},I:function(a){return document.getElementById(a)}};;
if ( 'undefined' === typeof go_local_bsocial_comments ) {
	var go_local_bsocial_comments = {};
}//end if

if ( 'undefined' === typeof go_local_bsocial_comments.event ) {
	go_local_bsocial_comments.event = {};
}//end if

( function( $ ) {
	'use strict';

	go_local_bsocial_comments.init = function() {
		if ( ! $( '#comment_post_ID' ).length ) {
			return;
		}//end if

		this.$flagging_comment = $();

		// override the default bsocial_comments.authenticated value because we don't care about
		// local WP authentication for our Gigaom stuff
		bsocial_comments.authenticated = false;

		this.deferred_action = {};
		this.deferred_action_type = null;

		$( document ).on( 'bsocial-comments-defer-action-for-auth', this.event.request_auth );
		$( document ).on( 'go-auth-success', this.event.auth_success );

		// because a comment can appear in multiple spots (featured and main comment stream), we need to track which
		// comment instance so we can open (and close) the form at the right spot
		$( document ).on( 'bsocial-comments-flag-not-authenticated', function( e, $comment ) {
			go_local_bsocial_comments.$flagging_comment = $comment;
		});

		bsocial_comments.filter_authenticated_request_args( this.filter_authenticated_request_args, 10 );
	};

	/**
	 * hooked to the bsocial_comments filter for authenticated request args
	 */
	go_local_bsocial_comments.filter_authenticated_request_args = function( args ) {
		if ( 'undefined' === typeof args.data.user.user_id || ! parseInt( args.data.user.user_id, 10 ) ) {
			args.data.user = go_local_bsocial_comments.fill_user_data( args.data.user );
		}//end if

		return args;
	};

	/**
	 * generates user data to be sent in ajax request
	 */
	go_local_bsocial_comments.fill_user_data = function( user ) {
		if ( user.user_id ) {
			return user;
		}

		if ( 'undefined' === typeof go_socialcomments.user.service ) {
			return user;
		}//end if

		if ( 'undefined' === typeof go_remote_identity.user.display_name ) {
			return user;
		}//end if

		user.comment_author = go_remote_identity.user.display_name;

		if ( 'twitter' === go_socialcomments.user.service ) {
			user.comment_author_email = go_socialcomments.user.twitter_id + '@twitter.id';
		} else if ( 'linkedin' === go_socialcomments.user.service ) {
			user.comment_author_email = go_socialcomments.user.linkedin_id + '@linkedin.id';
		} else {
			user.comment_author_email = go_socialcomments.user.email;
		}//end else

		return user;
	};

	/**
	 * slides down an auth box under a comment
	 */
	go_local_bsocial_comments.auth_on_comment = function( $comment ) {
		var $social = $('.credentials.credential-popup-logins:first').clone();

		var $auth = $( '<div class="feedback-box credential-social feedback-credentials" />' );

		$auth.append( $social );
		$auth.hide();
		$comment.after( $auth );
		$auth.slideDown( 'fast' );
	};

	/**
	 * defers an Ajax action and requests oauth
	 */
	go_local_bsocial_comments.defer_action_for_auth = function( args, type ) {
		this.deferred_action = args;
		this.deferred_action_type = type;
	};

	/**
	 * runs a stored ajax action
	 */
	go_local_bsocial_comments.run_delayed_action = function() {
		var comment_id = this.deferred_action.data.comment_id;
		var $comment = $( '.comment[data-comment-id="' + comment_id + '"]' );
		var check_if = this.deferred_action.data.check_if;

		if ( 'true' === $comment.data( 'comment-' + check_if ) ) {
			this.deferred_action = {};
			return;
		}//end if

		this.deferred_action.data.user = this.fill_user_data( {
			user_id: parseInt( bsocial_comments.logged_in_as, 10 )
		} );

		if ( 'flag' === this.deferred_action.data.direction && 'flag' === $comment.attr( 'data-comment-flag' ) ) {
			this.$flagging_comment.find( '.feedback-box:first' ).attr( 'data-type', 'flag-submitted' ).slideUp( 'fast' );
			this.deferred_action = {};
			return;
		} else if ( 'flag' === this.deferred_action.data.direction ) {
			this.$flagging_comment.find( '.feedback-box:first' ).attr( 'data-type', 'flag-logged-in' ).slideDown( 'fast' );
			this.deferred_action = {};
			return;
		}//end if

		this.$flagging_comment = $();

		this.deferred_action.success = function() {
			var comment_id = go_local_bsocial_comments.deferred_action.data.comment_id;
			var $comment = $( '.comment[data-comment-id="' + comment_id + '"]' );
			$comment.removeClass( 'faving' );

			var $feedback = $comment.find( '.feedback-box:first' );
			if ( $feedback.find( '.fave-logged-out' ).is( ':visible' ) ) {
				// if the fave wasn't already faved by the user, increment the counter
				if ( 'fave' !== $comment.first().attr( 'data-comment-fave' ) ) {
					bsocial_comments.adjust_fave_count( $comment, 'increment' );
				}//end if

				// set the fave state on the comment
				bsocial_comments.set_fave_state( comment_id, 'fave' );

				// hide the feedback box
				$feedback.slideUp( 'fast' );
			}//end if
		};

		$.ajax( this.deferred_action );
	};

	/**
	 * react to deferred ajax actions
	 */
	go_local_bsocial_comments.event.request_auth = function( e, args, type ) {
		go_local_bsocial_comments.defer_action_for_auth( args, type );
	};

	/**
	 * event to handle the go-auth-success trigger
	 */
	go_local_bsocial_comments.event.auth_success = function( e, user_data ) {
		// let bsocial-comments know that we've authenticated
		bsocial_comments.authenticated = true;
		bsocial_comments.request_comment_states( user_data );

		if ( 'undefined' === typeof go_local_bsocial_comments.deferred_action.url ) {
			return;
		}//end if

		$( document ).on( 'bsocial-comments-parsed-comment-states', function() {
			go_local_bsocial_comments.run_delayed_action();
		});
	};

	$( function() {
		go_local_bsocial_comments.init();
	});
})( jQuery );
;
(function( $ ) {
	'use strict';

	var $ads = $( '.go-ad' );

	// hook to go-init and define appropriate ad slots
	amplify.subscribe( 'go-init', function() {
		// let's define some ad slots
		$ads.each(function() {
			var $ad = $( this );
			var $ad_container = $ad.find( '.ad-container' );
			var ad_slot = $ad_container.data( 'ad-slot' ) || '';
			var div_id = $ad_container.attr( 'id' );

			if ( ! ad_slot ) {
				return;
			}//end if

			var dfp = $ad_container.data( 'ad-dfp' );
			var dimensions = [ $ad_container.data( 'ad-width' ), $ad_container.data( 'ad-height' ) ];

			// Define the slot if the ad is a ( billboard ad and is visible ) OR if the ad isn't a billboard ad
			if ( $ad.is( ':visible' ) ) {
				googletag.cmd.push( function() {
					googletag.defineSlot( dfp, dimensions, div_id ).addService( googletag.pubads() );
					go_ads.defined_slots.push( ad_slot );

					if ( go_ads.debug ) {
						console.log( 'go-ads defining slot: ' + ad_slot, dfp, dimensions, div_id );
					}//end if
				});
			}//end if
		});

		// Set up DFP targeting, and enable services. For all ads that have been defined, display them.
		googletag.cmd.push( function() {
			for ( var j in go_ads.dfp_targeting ) {
				googletag.pubads().setTargeting( go_ads.dfp_targeting[ j ][0], go_ads.dfp_targeting[ j ][1] );
				if ( go_ads.debug ) {
					console.log( 'go-ads setTargeting', go_ads.dfp_targeting[ j ][0], go_ads.dfp_targeting[ j ][1] );
				}//end if
			}//end for
			googletag.pubads().enableSingleRequest();
			googletag.enableServices();

			if ( go_ads.debug ) {
				console.log( 'go-ads enabling services' );
			}//end if

			// now that services have been enabled, let's display the ads
			$ads.each(function() {
				var $ad = $( this );
				var $ad_container = $ad.find( '.ad-container' );
				var ad_slot = $ad_container.data( 'ad-slot' ) || '';
				var div_id = $ad_container.attr( 'id' );

				if ( ! ad_slot || -1 === go_ads.defined_slots.indexOf( ad_slot ) ) {
					return;
				}//end if

				if ( go_ads.debug ) {
					console.log( 'go-ads displaying ' + div_id );
				}//end if

				googletag.display( div_id );
			});
		});
	});

	// @TODO remove this when waterfall redesign is done
	if ( ! $( 'body.theme-preview' ).length ) {
		/**
		 * Refresh borked ads after a resize event happens
		 */
		amplify.subscribe( 'go-resize', function( states ) {
			if ( false === gigaom.resize.initial ) {
				// don't generated ads immediately on resize, instead wait a few milliseconds in
				// the event that the user is still dragging
				gigaom.resize.ad_timer = setTimeout( function() {

					// any ads that were hidden but are now visible, make sure the slot is defined and the ad is displayed
					$ads.each( function() {
						var $ad = $( this );
						var $ad_container = $ad.find( '.ad-container' );
						// if the ad-container has a div child, it has already been enabled and displayed. bail.
						if ( $ad_container.find( 'div' ).length ) {
							return;
						}//end if

						var ad_slot = $ad_container.data( 'ad-slot' ) || '';
						var div_id = $ad_container.attr( 'id' );

						if ( ! ad_slot || ! $ad.is( ':visible' ) ) {
							return;
						}//end if

						var dfp = $ad_container.data( 'ad-dfp' );
						var dimensions = [ $ad_container.data( 'ad-width' ), $ad_container.data( 'ad-height' ) ];

						googletag.cmd.push( function() {
							googletag.defineSlot( dfp, dimensions, div_id ).addService( googletag.pubads() );
							go_ads.defined_slots.push( ad_slot );
							googletag.display( div_id );

							if ( go_ads.debug ) {
								console.log( 'go-ads defining slot: ' + ad_slot, dfp, dimensions, div_id );
								console.log( 'go-ads displaying ' + div_id );
							}//end if
						});
					});

					googletag.pubads().refresh();
					amplify.publish( 'go-ads-refresh', states );
				}, 500 );
			}
		});
	}//end if
})( jQuery );
;
(function() {
	var ajaxurl = window.ajaxurl || '/wp-admin/admin-ajax.php',
		data = window.wpcomVipAnalytics,
		dataQs, percent;

	if ( typeof XMLHttpRequest === 'undefined' ) {
		return;
	}

	if ( ! data ) {
		return;
	}

	percent = ~~data.percentToTrack;
	if ( percent && percent < 100 && ( ~~( ( Math.random() * 100 ) + 1 ) > percent ) ) {
		return;
	}

	dataQs = 'action=wpcom_vip_analytics';

	for ( var key in data ) {
		if ( key === 'percentToTrack' ) {
			continue;
		}
		if ( data.hasOwnProperty( key ) ) {
			dataQs += '&' +
				encodeURIComponent( key ).replace(/%20/g, '+' ) + '=' +
				encodeURIComponent( data[key] ).replace(/%20/g, '+' );
		}
	}

	function sendInfo() {
		var xhr = new XMLHttpRequest();
		xhr.open( 'POST', ajaxurl, true );
		xhr.setRequestHeader( 'Content-type', 'application/x-www-form-urlencoded' );
		xhr.send( dataQs );
	}

	// Delay for some time after the document is ready to ping
	function docReady() {
		setTimeout( function() {
			sendInfo();
		}, 1500 );
	}

	if ( document.readyState === 'complete' ) {
		docReady.apply();
	}
	else if ( document.addEventListener ) {
		document.addEventListener( 'DOMContentLoaded', docReady, false );
	}
	else if ( document.attachEvent ) {
		document.attachEvent( 'onreadystatechange', docReady );
	}
})();
;
if ( 'undefined' === typeof go_contentwidgets ) {
	var go_contentwidgets = {
		layout_preferences: {},
		single_use_gap_per_pass: false
	};
}//end id

(function( $ ) {
	'use strict';

	go_contentwidgets.full_inject_complete = false;
	go_contentwidgets.current = Date.now();
	// set up blackout selectors. NOTE: blockquotes are not blackouts except when they are tweet-embeds
	go_contentwidgets.blackout_selector = '> *:not(p,blockquote:not(.twitter-tweet),h1,h2,h3,h4,h5,h6,ol,ul,script,address)';

	go_contentwidgets.log = function( text ) {
		go_contentwidgets.current = Date.now();
		//console.info( text, go_contentwidgets.current - go_contentwidgets.last );
		go_contentwidgets.last = go_contentwidgets.current;
	};

	go_contentwidgets.events = function() {
		// compatibility with bcms wijax widgets
		$( document ).on( 'wijax-loaded', function( event, widget_id ) {
			var $widget = $( document.getElementById( widget_id ) );
			if ( $widget.closest( '#hidden-sidebar' ).length > 0 ) {
				go_contentwidgets.single_widget_inject( $widget );
			}//end if
		} );

		// watch for resizes and re-inject all the things
		$( document ).on( 'go-resize', function( e, states ) {
			if ( 'full' === states.to ) {
				go_contentwidgets.unbookmark_ads();

				if ( false === go_contentwidgets.full_inject_complete ) {
					go_contentwidgets.auto_inject();
				}//end if
			} else {
				var $ad_b_bookmark = $( document.getElementById( 'ad-b-bookmark' ) );

				if ( $ad_b_bookmark.length ) {
					return;
				}//end if

				go_contentwidgets.inject_small();
			}//end else
		});
	};

	go_contentwidgets.init = function() {
		this.loading = true;

		this.start = Date.now();
		this.last = this.start;
		this.log( 'begin init' );

		this.shortest_widget_height = 10000;
		this.tallest_widget_height = 0;
		this.insert = [];
		this.inventory = {
			blackouts: [],
			gaps: []
		};

		this.$body = $( document.getElementById( 'body' ) );
		this.$content = this.$body.find( '.post section.body.entry-content > div' );

		this.$first_element = this.$content.find( ':first' );
		this.$images = this.$content.find( 'img' );

		this.$ad_b = $( document.getElementById( 'ad-b' ) );
		this.$ad_c = $( document.getElementById( 'ad-c' ) );

		this.$post = this.$content.closest( '.post' );

		this.suppress_house_ctas = this.$post.hasClass( 'suppress-house-ctas' );
		this.suppress_ads = this.$post.hasClass( 'suppress-ads' );

		$( '.alignleft' ).each( function() {
			var $el = $( this );
			var $el_to_wrap = $();

			if ( $el.closest( '.aligncenter' ).length
				// handle images with captions that are aligned left and already wrapped
			    || $el.parents( '.alignleft' ).length ) {
				return;
			}//end if

			if ( $el.closest( 'picture' ).length ) {
				$el_to_wrap = $el.closest( 'picture' );
			} else {
				$el_to_wrap = $el;
			}//end else

			$el_to_wrap.wrap( '<div class="go-contentwidgets-align-container go-contentwidgets-alignleft"/>' );
			$el.css( 'height', 'auto' );
		});

		$( '.alignright' ).each( function() {
			var $el = $( this );
			var $el_to_wrap = $();

			if ( $el.closest( '.aligncenter' ).length
				// handle images with captions that are aligned right and already wrapped
			    || $el.parents( '.alignright' ).length ) {
				return;
			}//end if

			if ( $el.closest( 'picture' ).length ) {
				$el_to_wrap = $el.closest( 'picture' );
			} else {
				$el_to_wrap = $el;
			}//end else

			$el_to_wrap.wrap( '<div class="go-contentwidgets-align-container go-contentwidgets-alignright"/>' );
			$el.css( 'height', 'auto' );
		});

		this.collect_widgets();

		// we do the standard auto_inject for 960px and greater
		if ( $( 'body' ).outerWidth() >= 960 ) {
			this.auto_inject();
		} else {
			this.inject_small();
		}//end else

		this.$content.find( '.layout-box-thing' ).remove();
		this.$body.addClass( 'rendered' );
		go_contentwidgets.current = Date.now();

		$( document ).trigger( 'go-contentwidgets-complete' );
		this.loading = false;
	};

	/**
	 * inject ads b and c into the content of a post
	 */
	go_contentwidgets.inject_small = function() {
		if ( this.suppress_ads ) {
			return;
		}//end if

		var $stuff = $( '.entry-content > .container > *:not(.layout-box-insert,.go-contentwidgets-spacer,.bookmarked-widget)' );
		var $ad_b_container = this.$ad_b.closest( '.widget-go-ads' );
		var $ad_c_container = this.$ad_c.closest( '.widget-go-ads' );

		$ad_b_container.removeClass( 'small-inject' );
		$ad_c_container.removeClass( 'small-inject' );

		var $ad_b_bookmark = $( '<span id="ad-b-bookmark"/>' );
		var $ad_c_bookmark = $( '<span id="ad-c-bookmark"/>' );

		$ad_b_container.before( $ad_b_bookmark );
		$ad_c_container.before( $ad_c_bookmark );

		var insert_after = 0;

		// try to find a spot that isn't right next to a floated element
		$stuff.each( function() {
			var $el = $( this );

			if ( $el.find( '.go-contentwidgets-alignright,.go-contentwidgets-alignleft' ).length ) {
				insert_after++;
			}//end if
		});

		var inject_location = insert_after;

		// if we have more than 2 elements in the post, inject after the first safe spot
		if ( $stuff.length >= 3 ) {
			inject_location += 1;

			// make sure we haven't gone too far
			if ( $stuff.length < inject_location ) {
				inject_location--;
			}//end if
		}//end if

		// We can't inject if the immediately previous element or two elements previous are aligned elements
		if (
			$stuff.eq( inject_location ).prev().find( '.go-contentwidgets-aligright,.go-contentwidgets-alignleft' ).length
			|| $stuff.eq( inject_location ).prev().prev().find( '.go-contentwidgets-aligright,.go-contentwidgets-alignleft' ).length
		) {
			inject_location++;
		}//end if

		// if our inject_location is less than the length of stuff, we still have an injection point
		if ( inject_location < $stuff.length ) {
			$stuff.eq( inject_location ).after( $ad_b_container );
			$ad_b_container.addClass( 'small-inject' );
		}//end if

		$( '.post-page-tags > .sorted_tags' ).after( $ad_c_container );
		$ad_c_container.addClass( 'small-inject' );
	};

	/**
	 * place ads b and c back where they belong
	 */
	go_contentwidgets.unbookmark_ads = function() {
		var $ad_b_bookmark = $( document.getElementById( 'ad-b-bookmark' ) );
		var $ad_c_bookmark = $( document.getElementById( 'ad-c-bookmark' ) );

		if ( $ad_b_bookmark.length ) {
			$ad_b_bookmark.replaceWith( this.$ad_b.closest( '.widget-go-ads' ) );
		}

		if ( $ad_c_bookmark.length ) {
			$ad_c_bookmark.replaceWith( this.$ad_c.closest( '.widget-go-ads' ) );
		}
	};

	go_contentwidgets.collect_widgets = function() {
		go_contentwidgets.log( 'collecting widgets' );

		var not = '.widget_wijax';

		if ( this.suppress_house_ctas ) {
			not += ',.go-thisorthat-widget';
		}

		if ( this.suppress_ads ) {
			$( '.widget-go-ads' ).remove();
		}

		this.$widgets = $( document.getElementById( 'hidden-sidebar' ) ).find( '> div:not( ' + not + ' )' );
		this.$widgets.each( function() {
			var $el = $( this );

			go_contentwidgets.add_widget( $el );
		} );
		go_contentwidgets.log( 'finished collecting widgets' );
	};

	go_contentwidgets.add_widget = function( $widget ) {
		var widget_id = $widget.attr( 'id' );

		$widget.addClass( 'layout-box-insert' ); // @todo, this may not be needed long term, but for now it makes the CSS easier

		var widget = {
			name: widget_id,
			$el: $widget,
			height: parseInt( $widget.outerHeight( true ), 10 ) + 16, // reported height of the element and about 16px for some buffer
			location: 'right',
			preferbottom: false
		};

		if ( widget.height < this.shortest_widget_height ) {
			this.shortest_widget_height = widget.height;
		}//end if

		if ( widget.height > this.tallest_widget_height ) {
			this.tallest_widget_height = widget.height;
		}//end if

		if ( 'undefined' !== typeof this.layout_preferences[ widget_id ] ) {
			if (
				'undefined' !== typeof this.layout_preferences[ widget_id ].direction
				&& 'bottom' === this.layout_preferences[ widget_id ].direction
			) {
				widget.preferbottom = true;
			}//end if

			if (
				'undefined' !== typeof this.layout_preferences[ widget_id ].location
				&& 'any' !== this.layout_preferences[ widget_id ].location
			) {
				widget.location = this.layout_preferences[ widget_id ].location;
			}//end if
		}//end if

		if ( widget.location ) {
			$widget.addClass( 'layout-box-insert-'.concat( widget.location ) );
		}//end if

		this.insert.push( widget );
		return( widget );
	};

	go_contentwidgets.single_widget_inject = function( $widget ) {
		if ( this.loading ) {
			// sleep here and try again since other injections are actively happening.
			setTimeout( function() {
				go_contentwidgets.single_widget_inject( $widget );
			}, 10 );
		}//end if

		this.loading = true;

		this.reset();

		// identify all the normal blackouts and gaps
		this.identify_blackouts();

		// blackout everything from the bottom of the current viewport and up!
		var scroll_bottom = $( window ).scrollTop() + $( window ).height();
		var content_scroll_top = this.$content.offset().top;

		var end = scroll_bottom - content_scroll_top;

		var blackout = {
			$el: this.$first_element,
			start: 0,
			end: end,
			height: end
		};

		var new_blackouts = [ blackout ];
		for ( var i in this.inventory.blackouts ) {
			if ( this.inventory.blackouts[ i ].end > blackout.end ) {
				 new_blackouts.push( this.inventory.blackouts[ i ] );

				 if ( blackout.end > this.inventory.blackouts[ i ].start ) {
					blackout.end = this.inventory.blackouts[ i ].start;
					blackout.height = blackout.end;
				}//end if
			}
		}//end for
		this.inventory.blackouts = new_blackouts;

		this.identify_gaps();

		var injectable = this.add_widget( $widget );
		this.inject_item( injectable );

		this.loading = false;
	};

	/**
	 * auto injects items in order
	 */
	go_contentwidgets.auto_inject = function() {
		// before doing a full auto inject, all images need to have their heights set
		this.$images.each( function() {
			var $img = $( this );

			var style = $img.attr( 'style' );

			// if there are legacy floats or clears, we need to toss them out
			if ( 'undefined' !== typeof style && style ) {
				if ( style.match( /float/ ) ) {
					style = style.replace( /float\:[ \t]*(right|left);?/, '' );
				}//end if

				if ( style.match( /clear/ ) ) {
					style = style.replace( /clear\:[ \t]*(right|left|both);?/, '' );
				}//end if

				$img.attr( 'style', style );
			}

			if ( $img.attr( 'width' ) < $img.closest( '.entry-content' ).width() ) {
				var height = $img.attr( 'height' );

				// only set the height from the attribute if there is one
				if ( 'undefined' !== typeof height && height ) {
					$img.css( 'height', $img.attr( 'height' ).concat( 'px' ) );
				}//end if
			} else {
				$img.css( 'height', 'auto' );
			}//end else
		});

		for ( var i = 0, length = go_contentwidgets.insert.length; i < length; i++ ) {
			go_contentwidgets.calc();
			go_contentwidgets.inject_item( go_contentwidgets.insert[ i ] );
		}// end foreach

		// manual heights were added to all images to enable proper insertion. Let's remove the manual heights
		// so our CSS will work as expected
		this.$images.css( 'height', '' );

		this.full_inject_complete = true;
	};

	/**
	 * get measurement attributes for a given element
	 *
	 * @param $el jQuery element to measure
	 * @return object with measurement attributes
	 */
	go_contentwidgets.attributes = function( $el ) {
		var start;
		var margin_top = $el.css( 'margin-top' );

		margin_top = parseInt( margin_top.replace( 'px', '' ), 10 );

		// if we're looking at an item in the list, we need to get the offset of the li, not the item itself
		var $closest_li = $el.closest( 'li' );
		if ( $closest_li.length ) {
			start = $closest_li.get( 0 ).offsetTop;
		} else {
			// otherwise, just get the offset value of the element
			start = $el.get( 0 ).offsetTop;
		}//end else

		start -= margin_top;

		var height = parseInt( $el.outerHeight( true ), 10 );
		var end = start + height;

		var data = {
			$el: $el,
			start: start,
			end: end,
			height: height
		};

		return data;
	};

	go_contentwidgets.overlay = function( $el, start, height, type ) {
		var $overlay = $( '<div class="layout-box-thing" style="top:' + start + 'px;height:' + height + 'px;"></div>' );

		if ( 'gap' === type ) {
			$el.before( $overlay );
		} else if( 'solo-gap' === type ) {
			$el.append( $overlay );
		} else {
			$el.after( $overlay );
		}// end else

		return $overlay;
	};

	go_contentwidgets.reset = function() {
		this.$content.find( '.layout-box-thing, .go-contentwidgets-spacer' ).remove();
		this.inventory = {
			blackouts: [],
			gaps: []
		};
	};

	go_contentwidgets.calc = function() {
		go_contentwidgets.log( 'begin calc and reset' );
		this.reset();
		go_contentwidgets.log( 'end reset/begin identify blackouts' );
		this.identify_blackouts();
		go_contentwidgets.log( 'end identify blackouts/begin identify gaps' );
		this.identify_gaps();
		go_contentwidgets.log( 'end identify gaps and calc' );
	};

	go_contentwidgets.identify_blackouts = function() {

		go_contentwidgets.log( 'before find :visible' );
		// find top level blackouts
		// since :visible isn't native CSS, following the jQuery recommendation of running it after a pure CSS selector
		this.$content.find( this.blackout_selector ).filter( ':visible' ).each( function() {
			var $el = $( this );
			var attr = go_contentwidgets.attributes( $el );
			go_contentwidgets.inventory.blackouts.push( attr );
		});

		go_contentwidgets.log( 'after find :visible / before find children' );
		// find child blackouts
		this.$content.find( '> p *, > ol *, > ul *' ).filter( 'img,iframe,.layout-box-insert' ).each( function() {
			var $el = $( this );
			var attr = go_contentwidgets.attributes( $el );
			// since this is a child, after we've calculated the blackout grab its parent p
			attr.$el = $el.closest( 'p,li' );
			go_contentwidgets.inventory.blackouts.push( attr );
		});

		this.inventory.blackouts.sort( this.sort_by_start );

		go_contentwidgets.log( 'after find children / before blackout overlay generation' );
	};

	/**
	 * sorting function used only by identify_blackouts
	 */
	go_contentwidgets.sort_by_start = function( a, b ) {
		var a_start = a.start;
		var b_start = b.start;
		return ( ( a_start < b_start ) ? -1 : ( ( a_start > b_start ) ? 1 : 0 ) );
	};

	go_contentwidgets.adjust_down = function( $injectable, distance ) {
		var alignment_class = 'layout-box-insert-right';

		distance = Math.round( distance / 8 ) * 8;

		if ( ! $injectable.hasClass( alignment_class ) ) {
			alignment_class = 'layout-box-insert-left';
		}//end if

		$injectable.before( $( '<div class="go-contentwidgets-spacer '+ alignment_class + '" style="height:' + distance +'px"/>' ) );
	};

	go_contentwidgets.identify_gaps = function() {
		var start = 0;
		var gap;
		var i;
		var gap_height;
		var length;
		var first_el_start;

		if ( 0 === this.inventory.blackouts.length ) {
			gap = {};
			gap.$overlay = this.overlay( this.$content, start, this.$content.outerHeight(), 'solo-gap' );
			gap.$first_el = this.$first_element;

			this.inventory.gaps.push( gap );
		}//end if
		else {
			var previous_blackout = null;
			var tmp;
			for ( i = 0, length = this.inventory.blackouts.length; i < length; i++ ) {
				var blackout = this.inventory.blackouts[ i ];

				if ( blackout.start > start ) {
					gap_height = blackout.start - start;

					// if the gap height isn't tall enough for our shortest widget, don't bother with it
					if ( 0 === gap_height || gap_height < this.shortest_widget_height ) {
						// check if the there was a previous blackout and if it was a right insert, if so, rebalance
						if ( null !== previous_blackout && previous_blackout.$el.hasClass( 'layout-box-insert' ) ) {
							// only gap adjust right aligned elements or left aligned elements if the next element is not a left gap blocker
							if (
								previous_blackout.$el.hasClass( 'layout-box-insert-right' )
								|| ! this.left_blocker_in_gap( previous_blackout.$el.next(), blackout.start )
							) {
								this.adjust_down( previous_blackout.$el, gap_height / 2 );

								// if the blackout has been adjusted down, recalculate the start/end
								blackout.start = blackout.$el.position().top;
								blackout.end = blackout.start + blackout.height;
							}//end if
						}//end if

						start = blackout.end;
						previous_blackout = blackout;
						continue;
					}//end if

					gap = {};
					gap.$overlay = this.overlay( blackout.$el, start, gap_height, 'gap' );
					gap.$first_el = [];
					gap.height = gap_height;

					if ( 0 === start ) {
						tmp = this.attributes( this.$first_element );

						if ( tmp.end <= blackout.start ) {
							gap.$first_el = this.$first_element;
						}//end if
					}//end if
					else {
						tmp = this.attributes( previous_blackout.$el.next() );

						// as we attempt to find an element below the blackout, we'll need to track
						// how we're looping over list items and ol/uls
						var jumping_out_of_list = false;

						// find an element below the blackout
						while ( tmp.start < previous_blackout.end ) {
							// assume we aren't jumping out of a list
							jumping_out_of_list = false;

							// if the current item is the last li, we need to jump back out of the list
							if ( tmp.$el.is( 'li' ) && ! tmp.$el.next().length ) {
								tmp.$el = tmp.$el.closest( 'ol,ul' );
								jumping_out_of_list = true;
							}//end if

							tmp.$el = tmp.$el.next();

							// if the current element is an ol/ul, we need to traverse INTO the list. Unless, of course, we just jumped out of one.
							if ( tmp.$el.is( 'ul,ol' ) && ! jumping_out_of_list ) {
								tmp.$el = tmp.$el.find( 'li:first' );
							}//end if

							if ( tmp.$el.is( '.layout-box-thing' ) ) {
								continue;
							}//end if

							if ( ! tmp.$el.length ) {
								break;
							}//end if

							tmp = this.attributes( tmp.$el );
						}// end while

						if ( tmp.start >= previous_blackout.end && tmp.end < blackout.start ) {
							gap.$first_el = tmp.$el;
						}//end if
					}//end else

					if ( gap.$first_el.length ) {

						if ( 'undefined' !== typeof previous_blackout && previous_blackout ) {
							first_el_start = gap.$first_el.position().top;

							// make sure the height is calculated correctly starting from the first injectable area
							gap.height = gap.height - ( first_el_start - previous_blackout.end );
							gap.start = first_el_start;
						}//end if

						// if there isn't enough room for the shortest widget, don't add the gap
						if ( gap.height > this.shortest_widget_height ) {
							this.inventory.gaps.push( gap );
						}//end if
					}//end if
				}//end if

				start = blackout.end;
				previous_blackout = blackout;
			}//end for

			if ( previous_blackout && previous_blackout.end < this.$content.outerHeight() ) {
				gap_height = this.$content.outerHeight() - previous_blackout.end;
				// find the last gap below the final blackout

				// if the gap height isn't tall enough for our shortest widget, don't bother doing more stuff with it
				if ( gap_height > this.shortest_widget_height ) {
					gap = {};
					gap.$overlay = this.overlay( previous_blackout.$el, start, ( this.$content.outerHeight() - start ), 'last-gap' );
					gap.$first_el = gap.$overlay.next();
					gap.height = gap_height;

					// check that the element we found is below the blackout
					// @note: slight fear that this could cause an infinite loop
					while ( gap.$first_el.length && 'undefined' !== typeof gap.$first_el.get( 0 ).offsetTop && gap.$first_el.get( 0 ).offsetTop < previous_blackout.end ) {
						gap.$first_el = gap.$first_el.next();
					}// end while

					// make sure the gap has an element in it, if not, it can't be counted
					if ( gap.$first_el.length && gap.$first_el.get( 0 ).offsetTop ) {
						first_el_start = gap.$first_el.position().top;

						// make sure the height is calculated correctly starting from the first injectable area
						gap.height = gap.height - ( first_el_start - previous_blackout.end );
						gap.start = first_el_start;

						// if there isn't enough room for the shortest widget, don't add the gap
						if ( gap.height > this.shortest_widget_height ) {
							this.inventory.gaps.push( gap );
						}//end if
					}//end if
				}//end if
			}//end if
		}//end else
	};

	go_contentwidgets.inject_item = function( injectable ) {
		var i;
		var length = 0;
		var $injection_point = null;
		var gap = null;
		var injection_gap = null;
		var $tmp;
		go_contentwidgets.log( 'injecting injectable' );

		var total_gap_height = 0;
		var tallest_gap = null;

		// let's pregame the gaps. We're finding the height of all gaps that could hold widgets
		// as well as finding the tallest gap
		for ( i = 0, length = this.inventory.gaps.length; i < length; i++ ) {
			gap = this.inventory.gaps[ i ];
			var gap_height = gap.$overlay.outerHeight();
			if ( gap_height < this.shortest_widget_height ) {
				continue;
			}//end if

			// is this gap the tallest one that we've found so far?
			if (
				null === tallest_gap
				|| gap_height > this.inventory.gaps[ tallest_gap ].$overlay.outerHeight()
			) {
				tallest_gap = i;
			}//end else if

			total_gap_height += gap_height;
		}//end for

		// find a place to inject the injectable
		for ( i = 0, length = this.inventory.gaps.length; i < length; i++ ) {
			gap = this.attributes( this.inventory.gaps[ i ].$overlay );
			gap.$overlay = this.inventory.gaps[ i ].$overlay;
			gap.$first_el = this.inventory.gaps[ i ].$first_el;

			// if we are inserting the tallest widget, let's stick it in the biggest gap
			if ( injectable.height === this.tallest_widget_height ) {
				if ( i !== tallest_gap ) {
					continue;
				}//end if
			}//end if

			if ( gap.height > injectable.height ) {
				$injection_point = gap.$first_el;

				// let's find all widgets that aren't the one we're injecting (which is the first one)
				var $remaining = $( document.getElementById( 'hidden-sidebar' ) ).find( '> div:not(.widget_wijax)' ).filter( ':not(:first-child)' );
				var remaining_height = 0;

				// find the height of all those widgets
				$remaining.each( function() {
					remaining_height += $( this ).outerHeight();
				});

				// let's store off the next injection point because we'll probably need it
				var $next = $injection_point.next();

				// external_height holds the total gap height that isn't the gap we're in
				var external_height = total_gap_height - gap.height;

				// let's find how much vertical height we need inside THIS gap, which is the height of remaining injectables minus
				// the height outside of this gap
				var room_needed_inside_gap = remaining_height - external_height;

				// if there is more height outside of this gap than there are combined pixels on the remaining injectables, then
				// room_needed_inside_gap is negative. Which means we need 0 pixels in height for other widgets.
				if ( room_needed_inside_gap <= 0 ) {
					room_needed_inside_gap = 0;
				}//end if

				// while we're able to shift the element down, let's do so
				while (
					// if we're in the first gap, let's not shift down
					gap.start > 0
					// is there enough space to shift the injectable down and still inject other widgets?
					&& ( gap.height - injectable.height > room_needed_inside_gap )
					// IS there as next space?
					&& $next.length
					// Is the space at the top of the gap smaller than the "free" space at the bottom of the gap?
					&& ( $next.position().top - gap.start ) < ( gap.end - $next.position().top - room_needed_inside_gap )
				) {
					// Yup! move the injection point
					$injection_point = $next;
					$next = $injection_point.next();
				}//end while

				if ( injectable.preferbottom ) {
					// find the last injection_point in the gap where injectable will fit
					var next_injection_point = this.attributes( $injection_point );
					while ( next_injection_point.end <= gap.end && ( gap.end - next_injection_point.start ) > injectable.height ) {
						$injection_point = next_injection_point.$el;

						// we need to make sure we aren't selecting a blackout overlay
						$tmp = $injection_point.next( ':not(.layout-box-thing)' );

						// if there's nothing else to select, then we're done searching for an injection point
						if ( ! $tmp.length ) {
							break;
						}//end if

						next_injection_point = this.attributes( $tmp );
					}// end while
					injection_gap = gap;
				}//end if
				else {
					injection_gap = gap;
					break;
				}//end else
			}//end if
		}//end for

		if ( ! $injection_point ) {
			// Failed to inject
			return false;
		}// end if

		if ( $injection_point.is( 'li' ) ) {
			$injection_point.before( '<li class="injection-list-item"/>' );
			$injection_point.prev().append( injectable.$el );
		} else {
			$injection_point.before( injectable.$el );
		}//end else

		// if the injectable is the first element in the story, make sure it is on the right no matter what
		if (
			injectable.$el.hasClass( 'layout-box-insert-left' )
			&& (
				! injectable.$el.position().top
				|| ! injectable.$el.prev().length
			)
		) {
			injectable.$el.removeClass( 'layout-box-insert-left' ).addClass( 'layout-box-insert-right' );
		}//end if

		// determine if the left injection overlaps an element that should push it to the right
		// this is not super efficient, but we will be doing this rarely, so it's probably ok?

		if ( injectable.$el.hasClass( 'layout-box-insert-left' ) ) {
			var injectable_attrs = this.attributes( injectable.$el );

			var end = injection_gap.end < injectable_attrs.end ? injection_gap.end : injectable_attrs.end;

			if ( this.left_blocker_in_gap( $injection_point, end ) ) {
				injectable.$el.removeClass( 'layout-box-insert-left' ).addClass( 'layout-box-insert-right' );
			}//end if
		}//end if

		$( document ).trigger( 'go-contentwidgets-injected', {
			injected: injectable
		} );

		go_contentwidgets.log( 'end injecting injectable' );
	};

	go_contentwidgets.left_blocker_in_gap = function( $el, end ) {
		var tag;
		var injection_point = this.attributes( $el );

		var left_blockers = [
			'OL',
			'UL',
			'LI',
			'BLOCKQUOTE'
		];

		while ( injection_point.end <= end && injection_point.start < end ) {
			tag = injection_point.$el.prop( 'tagName' );

			if ( -1 !== $.inArray( tag, left_blockers ) ) {
				return true;
			}//end if

			injection_point = this.attributes( injection_point.$el.next() );
		}// end while

		tag = injection_point.$el.prop( 'tagName' );

		if ( -1 !== $.inArray( tag, left_blockers ) ) {
			return true;
		}//end if

		return false;
	};

	$( function() {
		go_contentwidgets.init();
		go_contentwidgets.events();
	});
})( jQuery );
;
/*!
 * ScribAuthority jQuery plugin
 * Author: Matthew Batchelder
 * Author URI: http://borkweb.com
 *
 * USAGE:
 *
 * Initialization:
 * $('#element').ScribAuthority({ taxonomies: [ 'something', 'tag' ] });
 *
 * Adding default items:
 * $('#element').ScribAuthority( 'items', [
 *   {
 *     taxonomy: 'something',
 *     term: 'some-term',
 *     data: {
 *       term: 'something:some-term'
 *     }
 *   },
 *   ...
 * ] );
 *
 * Adding results:
 * $('#element').ScribAuthority( 'results', [
 *   {
 *     taxonomy: 'something',
 *     term: 'some-term',
 *     data: {
 *       term: 'something:some-term'
 *     }
 *   },
 *   ...
 * ] );
 *
 */
(function( $ ) {
	'use strict';

	var defaults = {
		id: null,
		classes: null,
		custom_enabled: true,
		replace_field: true,
		labels: {
			results: 'Results'
		}
	};

	var selector = 'scrib-authority-box';
	var options = {};
	var html = {};
	var selectors = {};
	var timeout_handler = null;

	var methods = {
		init: function( params ) {

			if ( 'undefined' !== typeof params && 'undefined' !== typeof params.url ) {
				scrib_authority_suggest.url = params.url;
			}

			// fix the ajax url
			if ( 'https:' === window.location.protocol ) {
				scrib_authority_suggest.url = scrib_authority_suggest.url.replace( 'http:', 'https:' );
			} else {
				scrib_authority_suggest.url = scrib_authority_suggest.url.replace( 'https:', 'http:' );
			}//end if

			options = $.extend( defaults, params );

			var type = 'undefined' !== typeof this.attr( 'type' ) ? this.attr( 'type' ) : 'text';

			// set up the html injection variables
			html = {
				$wrapper : $( '<div/>', { class: selector } ),
				$item    : $( '<li/>', { class: selector + '-item' } ),
				$items   : $( '<ul/>', { class: selector + '-items' } ),
				$entry   : $( '<input/>', {
					type: type,
					class: selector + '-entry ' + selector + '-input'
				} )
			};

			// initilaize the common selectors that we'll be using
			selectors.wrapper   = '.' + selector;
			selectors.category  = selectors.wrapper + '-result-category';
			selectors.category_results  = selectors.wrapper + '-result-category-results';
			selectors.category_custom  = selectors.wrapper + '-result-category-custom';
			selectors.entry     = selectors.wrapper + '-entry';
			selectors.item      = selectors.wrapper + '-item';
			selectors.items     = selectors.wrapper + '-items';
			selectors.newitem   = selectors.wrapper + '-new';
			selectors.noresults = selectors.wrapper + '-no-results';
			selectors.results   = selectors.wrapper + '-results';
			selectors.close     = selectors.item + ' .close';

			var $results = $( '<ul/>', {
				class: selector +'-results'
			} );

			// create the <li> that'll hold the header and record <ul>
			var $results_li = $( '<li/>', {
				class: selector + '-result-category ' + selector + '-result-category-results'
			} );

			// add a header for the result li
			$results_li.append( $( '<header/>', {
				text: options.labels.results
			} ) );

			// add a container for result records
			$results_li.append( '<ul/>' );

			// add the result li
			$results.append( $results_li );

			if ( options.custom_enabled ) {
				var $custom_results_li = $( '<li/>', {
					class: selector + '-result-category ' + selector + '-result-category-custom'
				} );

				$custom_results_li.append( $( '<header/>', {
					text: 'Custom'
				} ) );

				$custom_results_li.append( '<ul/>' );

				$results.append( $custom_results_li );
			}//end if

			$results.find('.' + selector + '-result-category-results ul').append( $( '<li/>', {
				class: selector + '-no-results',
				text: 'No terms were found matching your search.'
			} ) );

			var $entry_container = $( '<div/>', {
				class: selector + '-entry-container'
			} );

			$entry_container.append( html.$entry );

			if ( ! options.replace_field ) {
				$entry_container.find( selectors.wrapper + '-input' ).removeClass( selectors.entry.substr( 1 ) );
			}//end if

			$entry_container.append( $results );

			return this.each( function() {
				var $orig;
				var $root;
				var $entry;

				// wrap and hide the original bound element
				$orig = $( this );
				$orig.wrap( html.$wrapper );

				if ( options.replace_field ) {
					$orig.hide();
				} else {
					$orig.addClass( selectors.entry.substr( 1 ) );
				}//end else

				// identify the root element for the Authority UI
				$root = $orig.closest( selectors.wrapper );

				// archive off the ID of the original bound element
				$root.data('target', $orig.attr('id'));

				// if there was an id attribute passed along in the options, set the id element of the root
				if( null !== options.id ) {
					$root.attr('id', options.id);
					options.id = null;
				}//end if

				// if there were some classes passed in the options, add those to the root
				if( null !== options.classes ) {
					if( options.classes instanceof Array ) {
						$.each( options.classes, function( index, value ) {
							$root.addClass( value );
						});
					} else {
						$root.addClass( options.classes );
					}//end else

					options.classes = null;
				}//end if

				// add the items container
				$root.append( html.$items );

				// add the entry/results container
				$root.append( $entry_container );

				//set top to the inverse of search-box margin to ensure it snugs up to the search box
				$entry_container.css('top', function() {
					var margin = $( selectors.entry ).css( 'margin-bottom' ).replace( 'px', '' );

					return parseInt( margin, 10 ) * -1;
				});

				$root.append( $( '<div/>', {
					class: selector + '-clearfix'
				} ) );

				if ( options.replace_field ) {
					$entry = $root.find( selectors.entry );
					for ( var attr, i = 0, attrs = $orig.get(0).attributes, length = attrs.length; i < length; i++ ) {
						attr = attrs.item( i );

						if ( 'name' !== attr.nodeName && 'class' !== attr.nodeName && 'id' !== attr.nodeName && 'type' !== attr.nodeName && 'style' !== attr.nodeName ) {
							$entry.attr( attr.nodeName, attr.nodeValue );
						}//end if
					}//end for
				}//end if

				methods.taxonomies( $(this), options.taxonomies );

				// click event: result item
				$root.on( 'click.scrib-authority-box MSPointerDown.scrib-authority-box', selectors.results + ' ' + selectors.item, function( e ) {
					e.preventDefault();

					methods.select_item( $(this), $root );
					methods.update_target( $root );
				});

				$root.$current_touch_item = null;
				$root.current_touch_y_pos = null;

				$root.on( 'touchstart.scrib-authority-box', selectors.results + ' ' + selectors.item, function( e ) {
					$root.$current_touch_item = $( this );
					$root.current_touch_y_pos = e.changedTouches[0].pageY;
				});

				$root.on( 'touchend.scrib-authority-box', selectors.results + ' ' + selectors.item, function( e ) {
					e.preventDefault();

					// if there isn't a touch start item, bail
					if ( ! $root.$current_touch_item ) {
						$root.$current_touch_item = null;
						$root.current_touch_y_pos = null;
						return;
					}//end if

					var original_item = $root.$current_touch_item.find( '.taxonomy' ).html();
					original_item = original_item + ':' + $root.$current_touch_item.find( '.term' ).html();

					var current_item = $( this ).find( '.taxonomy' ).html();
					current_item = current_item + ':' + $( this ).find( '.term' ).html();

					// if the end item is not the start item, bail
					if ( original_item !== current_item ) {
						$root.$current_touch_item = null;
						$root.current_touch_y_pos = null;
						return;
					}//end if

					// if there are no changedTouches, bail
					if ( 'undefined' === typeof e.changedTouches || 0 === e.changedTouches.length ) {
						$root.$current_touch_item = null;
						$root.current_touch_y_pos = null;
						return;
					}

					// if the changed touches moved more than 10 pixels in any direction, bail (we're probably scrolling)
					if ( ( $root.current_touch_y_pos + 10 ) < e.changedTouches[0].pageY || ( $root.current_touch_y_pos - 10 ) > e.changedTouches[0].pageY ) {
						$root.$current_touch_item = null;
						$root.current_touch_y_pos = null;
						return;
					}//end if

					$root.$current_touch_item = null;
					$root.current_touch_y_pos = null;

					methods.select_item( $(this), $root );
					methods.update_target( $root );
				});

				// click event: root element
				$root.on( 'click.scrib-authority-box touchstart.scrib-authority-box MSPointerDown.scrib-authority-box', function() {
					var $entry = $( this ).find( selectors.entry );
					var $results = $entry.closest( '.scrib-authority-box' ).find( '.scrib-authority-box-results.has-results' );

					// if the root element is clicked, focus the entry
					$entry.focus();

					// when focusing, if the input box already has content in it that returned results, show them
					if ( $entry.val() && $results.length ) {
						$results.addClass( 'show' );
					}//end if
				});

				// click event: handles dismissing the results box if clicking off of the box or search
				$( document ).on( 'click.scrib-authority-box-cancel touchstart.scrib-authority-box-cancel MSPointerDown.scrib-authority-box-cancel', function( e ) {
					var $el = $( e.target );

					if ( $el.is( '.scrib-authority-box' ) || 0 !== $el.closest( '.scrib-authority-box').length ) {
						return;
					}//end if

					methods.hide_results( $root );
				});

				// click event: base item
				$root.on( 'click.scrib-authority-box touchstart.scrib-authority-box MSPointerDown.scrib-authority-box', selectors.item, function( e ) {
					// all we want to do is stop propagation so the entry isn't auto-focused
					e.stopPropagation();
				});

				// click event: item close
				$root.on( 'click.scrib-authority-box touchstart.scrib-authority-box MSPointerDown.scrib-authority-box', selectors.close, function( e ) {
					// an item is being x-ed out.  remove it
					e.stopPropagation();

					methods.remove_item( $(this).closest( selectors.item ), $root );
					methods.update_target( $root );
				});

				$root.on( 'keydown.scrib-authority-box-down', selectors.entry, function( e ) {
					// the keys that are handled in here: navigation and selection
					var code = (e.keyCode ? e.keyCode : e.which);

					if ( 40 === code ) {
						// if DOWN arrow is pressed
						var $focused = methods.focused_result( $root );

						if ( ! $focused.length ) {
							$root.find( selectors.results + ' ' + selectors.item + ':first' ).addClass('focus');
						} else {
							if ( 0 === $focused.nextAll( selectors.item ).length ) {
								$focused.closest( selectors.category ).nextAll( selectors.category ).find( selectors.item + ':first' ).addClass('focus');
							} else {
								$focused.nextAll( selectors.item ).first().addClass('focus');
							}//end else

							$focused.removeClass('focus');
						}//end else
					}//end if
				});

				$root.on( 'keydown.scrib-authority-box-up', selectors.entry, function( e ) {
					// the keys that are handled in here: navigation and selection
					var code = (e.keyCode ? e.keyCode : e.which);

					if ( 38 === code ) {
						// if UP arrow is pressed
						var $focused = methods.focused_result( $root );

						if ( ! $focused.length ) {
							$root.find( selectors.results + ' ' + selectors.item + ':last' ).addClass('focus');
						} else {
							if ( 0 === $focused.prevAll( selectors.item ).length ) {
								$focused.closest( selectors.category ).prevAll( selectors.category ).find( selectors.item + ':first' ).addClass('focus');
							} else {
								$focused.prevAll( selectors.item ).first().addClass('focus');
							}//end else

							$focused.removeClass('focus');
						}//end else
					}//end if
				});

				// keydown event: entry field
				$root.on( 'keydown.scrib-authority-box-enter', selectors.entry, function( e ) {
					// the keys that are handled in here: navigation and selection
					var code = (e.keyCode ? e.keyCode : e.which);

					if( 13 === code ) {
						var $focused = methods.focused_result( $root );

						if ( $focused.length && methods.is_results_visible( $root ) ) {
							// if ENTER is pressed
							e.preventDefault();
							$focused.removeClass('focus').click();
							$root.find( selectors.entry ).val('');
							methods.hide_results( $root );
						} else if ( $.trim( $(this).val() ).length ){
							var val = $.trim( $(this).val() );
							$orig.val( val );

							$(this).trigger( 'scriblio-authority-enter', {
								value: val
							});
						}//end else
					}//end if
				});

				// keydown event: entry field
				$root.on( 'keydown.scrib-authority-box-esc', selectors.entry, function( e ) {
					// the keys that are handled in here: navigation and selection
					var code = (e.keyCode ? e.keyCode : e.which);

					if ( 27 === code ) {
						var $focused = methods.focused_result( $root );

						// if ESC is pressed
						$focused.removeClass('focus');
						methods.hide_results( $root );
					}//end if
				});

				// keyup event: entry field
				$root.on( 'keyup.scrib-authority-box', selectors.entry, function( e ) {
					// the keys that are handled in here: backspace, delete, and regular characters
					var code = (e.keyCode ? e.keyCode : e.which);
					var val = $(this).val();

					// disallow < and >
					if ( 188 === code || 190 === code ) {
						$(this).val( val.replace( '>', '' ).replace( '<', '' ) );
						return false;
					}//end if

					if ( 48 <= code || 8 === code || 46 === code ) {
						// if a valid char is pressed
						$root.find( selectors.newitem ).find('.term').html( val );
						if( 0 === $.trim( $(this).val() ).length ) {
							$root.closest( 'form' ).removeClass( 'has-text' );
							$root.find( selectors.results ).removeClass( 'has-results no-results' );
							methods.hide_results( $root );
						} else {
							$root.closest( 'form' ).addClass( 'has-text' );
							if ( timeout_handler ) {
								window.clearTimeout( timeout_handler );
							}//end if

							timeout_handler = window.setTimeout( function() {
								methods.search( $root, $root.find( selectors.entry ) );
							}, 300 );
						}//end else
					}//end if
				});
			});
		},
		/**
		 * This method generates a data string based on the currently selected items
		 *
		 * @param string which The data element to retrieve
		 */
		data_string: function() {
			var $el = methods.root( $(this) );
			var serialized = $el.ScribAuthority('serialize');

			var terms = [];

			$.each( serialized, function( index, value ) {
				terms.push( value.taxonomy + ':' + value.term );
			});

			return terms.join(',');
		},
		/**
		 * returns a focused result
		 *
		 * @param jQueryObject $root Root element for this UI widget
		 */
		focused_result: function( $root ) {
			return $root.find( selectors.results + ' .focus' );
		},
		/**
		 * generate item HTML based on an object.
		 *
		 * @param object data Object representing an item
		 */
		generate_item: function( data ) {
			var $item = html.$item.clone();

			// let's store the object that is used to generate this item.
			$item.data( 'origin-data', data );

			// loop over the properties in the item and add them to the HTML
			$.each( data, function( key, data_value ) {
				if ( ! data_value ) {
					return;
				}//end if

				// the only exception are the data elements.  Add them to the item's data storage
				if( 'data' === key ) {
					$.each( data_value, function( data_key, key_value ) {
						$item.data( data_key, key_value );
					});
				} else if ( 'taxonomy' === key ) {
					var $taxonomy = $( '<span/>', {
						class: key,
						text: data_value.labels.singular_name
					} );

					$item.append( $taxonomy );

					$taxonomy.attr( 'data-taxonomy', data_value.name );
				} else {
					var $inject = $( '<span/>', {
						class: key
					} );

					$inject.html( data_value );
					$item.prepend( $inject );
				}//end else
			});

			// gotta add the close box!
			$item.append( '<span class="close">x</span>' );

			return $item;
		},
		/**
		 * hide the results box
		 *
		 * @param jQueryObject $root Root element for this UI widget
		 */
		hide_results: function( $root ) {
			$root.find( selectors.results + '.show' ).removeClass('show');
		},
		/**
		 * add an item to either the results or the items HTML area
		 *
		 * @param jQueryObject $el Element for finding the root element
		 * @param String container Area the elements will be added to ( results or items )
		 * @param Object data Item definition object
		 */
		inject_item: function( $el, container, data ) {
			$el = methods.root( $el );
			var $item = methods.generate_item( data );

			if ( 0 !== $el.find( selectors[container] + ' ' + selectors.category ).length ) {
				$el.find( selectors[container] + ' ' + selectors.category + '-results ul' ).append( $item );
			} else {
				$el.find( selectors[container] ).append( $item );
			}//end else
		},
		/**
		 * determines if results are visible
		 *
		 * @param jQueryObject $root Root element for this UI widget
		 */
		is_results_visible: function( $root ) {
			return $root.find( selectors.results ).hasClass('show');
		},
		/**
		 * inject an item into the 'items' HTML area
		 *
		 * @param Object data Item definition object
		 */
		item: function( data ) {
			methods.inject_item( this, 'items', data );
		},
		/**
		 * populate the 'items' HTML area
		 *
		 * @param Array data Array of item definition objects to insert
		 */
		items: function( data ) {
			return this.each( function() {
				var $el = $(this);
				var $root = methods.root( $(this) );
				$root.data( 'items', data );

				$.each( data, function( i, value ) {
					$el.ScribAuthority('item', value);
				});
			});
		},
		/**
		 * Remove an item from the 'items' HTML area
		 *
		 * @param jQueryObject $item Item to remove
		 * @param jQueryObject $root Root html element for authority UI
		 */
		remove_item: function( $item, $root ) {
			var items = $root.data( 'items' ) || [];
			var new_items = [];
			var origin = $item.data( 'origin-data' );

			$.each( items, function( i, value ) {
				var temp_combo = value.taxonomy.name + ':' + value.term;
				var temp_origin_combo = origin.taxonomy.name + ':' + origin.term;
				if ( temp_combo !== temp_origin_combo ) {
					new_items.push( value );
				}//end if
			});

			$root.data( 'items', new_items );

			$item.remove();
		},
		/**
		 * inject an item into the 'results' HTML area
		 *
		 * @param Object data Item definition object
		 */
		result: function( data ) {
			methods.inject_item( this, 'results', data );
		},
		/**
		 * populate the 'results' HTML area
		 *
		 * @param Array data Array of item definition objects to insert
		 */
		results: function( data ) {
			return this.each( function() {
				var $el = $(this);
				var items = $el.data('items');

				if ( ! items ) {
					items = [];
				}//end if

				$el.find( selectors.results + ' ' + selectors.item + ':not(' + selectors.newitem + ')' ).remove();

				if ( data.length > 0 ) {
					$.each( data, function( i, value ) {
						// if the results item DOES NOT exist in the set of elements already selected,
						//   add it to the result area
						if ( 0 === $.grep( items, function( element ) { return element.data.term === value.data.term; }).length ) {
							$el.ScribAuthority('result', value);
						}//end if
					});
				}//end if
			});
		},
		/**
		 * locate the root Authority UI element
		 *
		 * @param jQueryObject $el Child element of root used to find root.
		 */
		root: function( $el ) {
			if( ! $el.hasClass( selector ) ) {
				$el = $el.closest( selectors.wrapper );
			}//end if

			return $el;
		},
		search: function( $root, $entry ) {
			var params = {
				s: $.trim( $entry.val() ),
				threshold: scrib_authority_suggest.threshold
			};

			if ( 0 === params.s.length ) {
				return;
			}//end if

			var url = scrib_authority_suggest.url;

			// we need to handle both pretty and admin-ajax URLs - so ? may or may not be present
			if ( -1 !== url.indexOf( '?' ) ) {
				url += '&callback=?';
			} else {
				url += '?callback=?';
			}//end else

			var xhr = $.getJSON( url, params );

			xhr.done( function( data ) {
				if ( typeof data !== 'undefined' ) {
					$root.ScribAuthority('results', data);
					methods.show_results( $root );
				}//end if
			});
		},
		/**
		 * Select an item from the 'results' HTML area and move it to the 'items area'
		 *
		 * @param jQueryObject $item Selected item
		 * @param jQueryObject $root Root Authority UI element
		 */
		select_item: function( $item, $root ) {
			var $newitem;
			// get the cached items object from the root element
			var items = $root.data('items') || [];

			// add the selected item's object data into the items object
			$root.data( 'items', items );

			if( $item.is( selectors.newitem ) ) {
				$newitem = $item.clone();
				$newitem.data('origin-data', {
					taxonomy: $item.find('.taxonomy').data('taxonomy'),
					term: $item.find('.term').html()
				});

				$newitem.find('.taxonomy').data('taxonomy', $item.find('.taxonomy').data('taxonomy'));

				$newitem.removeClass( selectors.newitem.substring( 1 ) ).appendTo( $root.find( selectors.items ) );
				items.push( $newitem.data( 'origin-data' ) );
			} else {
				$newitem = $item.clone();

				$root.find( selectors.items ).append( $newitem );
				items.push( $item.data( 'origin-data' ) );
			}//end else

			$root.find( selectors.entry ).focus();

			if( $root.find( selectors.items ).find( selectors.item ).length === 0 ) {
				$root.find( selectors.noitems ).show();
			}//end if

			// advertise that an item has been selected
			$item.trigger( 'scriblio-authority-item-selected', { item: $item });

			methods.hide_results( $root );
		},
		/**
		 * serialize the selected items into an array
		 */
		serialize: function() {
			var $el = methods.root( $(this) );
			var data = [];
			$el.find( selectors.items + ' ' + selectors.item ).each( function() {
				var $term = $(this);

				var row = {
					taxonomy: $term.find('.taxonomy').data('taxonomy'),
					term: $term.find('.term').html()
				};

				data.push( row );
			});

			return data;
		},
		/**
		 * display the results drop-down auto-completer
		 *
		 * @param jQueryObject $root Root Authority UI HTML element
		 */
		show_results: function( $root ) {
			var $results = $root.find( selectors.results );

			if( $results.find( '.scrib-authority-box-result-category-results ' + selectors.item ).length > 0 ) {
				$results.addClass( 'has-results' ).removeClass( 'no-results' );
				$results.find( selectors.noresults ).hide();
			} else {
				$results.removeClass( 'has-results' ).addClass( 'no-results' );
				$results.find( selectors.noresults ).show();
			}//end else

			if ( 0 !== $.trim( $root.find( selectors.entry ).val() ).length ) {
				$results.addClass('show');
			}//end if
		},
		taxonomies: function( $el, taxonomies ) {
			var $root = methods.root( $el );
			options.taxonomies = taxonomies;

			var $categories = $root.find( selectors.category + '-custom' ).find('ul');

			if ( options.taxonomies ) {
				$.each( options.taxonomies, function( i, value ) {
					var $item = $( '<li/>', {
						class: selector + '-item ' + selector + '-new'
					} );

					var $taxonomy = $( '<span/>', {
						class: 'taxonomy',
						text: value.labels.singular_name
					} );

					$item.append( $taxonomy );
					$item.prepend( '<span class="term"></span>' );
					$item.append( '<span class="close">x</span>' );
					$categories.append( $item );

					$taxonomy.attr( 'data-taxonomy', value.name );
				});
			}//end else
	  },
		/**
		 * update the target UI element (textarea or input, typically) with the serialized/converted
		 * selected items
		 *
		 * @param jQueryObject $root Root Authority UI element
		 */
		update_target: function( $root ) {
			var $target = $root.find( '#' + $root.data('target') );
			$target.val( $target.ScribAuthority('data_string', 'term') );
		}
	};

	$.fn.ScribAuthority = function( method ) {
    // Method calling logic
    if ( methods[method] ) {
      return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
    } else if ( typeof method === 'object' || ! method ) {
      return methods.init.apply( this, arguments );
    } else {
      $.error( 'Method ' +  method + ' does not exist on jQuery.ScribAuthority' );
    }
	};

})( jQuery );
;
function metaphone (word, phones) {
	// +   original by: Greg Frazier
	// +   improved by: Brett Zamir (http://brett-zamir.me)
	// +   improved by: Rafał Kukawski (http://kukawski.pl)
	// *     example 1: metaphone('Gnu');
	// *     returns 1: 'N'

	word = (word == null ? '' : word + '').toUpperCase();

	function isVowel (a) {
		return 'AEIOU'.indexOf(a) !== -1;
	}

	function removeDuplicates (word) {
		var wordlength = word.length,
				char1 = word.charAt(0),
				char2,
				rebuilt = char1;

		for (var i = 1; i < wordlength; i++) {
			char2 = word.charAt(i);

			if (char2 !== char1 || char2 === 'C' || char2 === 'G') { // 'c' and 'g' are exceptions
				rebuilt += char2;
			}
			char1 = char2;
		}

		return rebuilt;
	}

	word = removeDuplicates(word);

	var wordlength = word.length,
			x = 0,
			metaword = '';

	//Special wh- case
	if (word.substr(0, 2) === 'WH') {
		// Remove "h" and rebuild the string
		word = 'W' + word.substr(2);
	}

	var cc = word.charAt(0); // current char. Short name cause it's used all over the function
	var pc = ''; // previous char. There is none when x === 0
	var nc = word.charAt(1); // next char
	var nnc = ''; // 2 characters ahead. Needed later

	if (1 <= wordlength) {
		switch (cc) {
			case 'A':
				if (nc === 'E') {
					metaword += 'E';
				} else {
					metaword += 'A';
				}
				x += 1;
				break;
			case 'E': case 'I': case 'O': case 'U':
				metaword += cc;
				x += 1;
				break;
			case 'G': case 'K': case 'P':
				if (nc === 'N') {
					x += 1;
				}
				break;
			case 'W':
				if (nc === 'R') {
					x += 1;
				}
				break;
		}
	}

	for (; x < wordlength; x++) {
		cc = word.charAt(x);
		pc = word.charAt(x - 1);
		nc = word.charAt(x + 1);
		nnc = word.charAt(x + 2);

		if (!isVowel(cc)) {
			switch (cc) {
				case 'B':
					if (pc !== 'M') {
						metaword += 'B';
					}
					break;
				case 'C':
					if (x + 1 <= wordlength) {
						if (word.substr(x - 1, 3) !== 'SCH') {
							if (x === 0 && (x + 2 <= wordlength) && isVowel(nnc)) {
								metaword += 'K';
							} else {
								metaword += 'X';
							}
						} else if (word.substr(x + 1, 2) === 'IA') {
							metaword += 'X';
						} else if ('IEY'.indexOf(nc) !== -1) {
							if (x > 0) {
								if (pc !== 'S') {
									metaword += 'S';
								}
							} else {
								metaword += 'S';
							}
						} else {
							metaword += 'K';
						}
					} else {
						metaword += 'K';
					}
					break;
				case 'D':
					if (x + 2 <= wordlength && nc === 'G' && 'EIY'.indexOf(nnc) !== -1) {
						metaword += 'J';
						x += 2;
					} else {
						metaword += 'T';
					}
					break;
				case 'F':
					metaword += 'F';
					break;
				case 'G':
					if (x < wordlength) {
						if ((nc === 'N' && x + 1 === wordlength - 1) || (nc === 'N' && nnc === 'S' && x + 2 === wordlength - 1)) {
							break;
						}
						if (word.substr(x + 1, 3) === 'NED' && x + 3 === wordlength - 1) {
							break;
						}
						if (word.substr(x - 2, 3) === 'ING' && x === wordlength - 1) {
							break;
						}

						if (x + 1 <= wordlength - 1 && word.substr(x - 2, 4) === 'OUGH') {
							metaword += 'F';
							break;
						}
						if (nc === 'H' && x + 2 <= wordlength) {
							if (isVowel(nnc)) {
								metaword += 'K';
							}
						} else if (x + 1 === wordlength) {
							if (nc !== 'N') {
								metaword += 'K';
							}
						} else if (x + 3 === wordlength) {
							if (word.substr(x + 1, 3) !== 'NED') {
								metaword += 'K';
							}
						} else if (x + 1 <= wordlength) {
							if ('EIY'.indexOf(nc) !== -1) {
								if (pc !== 'G') {
									metaword += 'J';
								}
							} else if (x === 0 || pc !== 'D' || 'EIY'.indexOf(nc) === -1) {
								metaword += 'K';
							}
						} else {
							metaword += 'K';
						}
					} else {
						metaword += 'K';
					}
					break;
				case 'M': case 'J': case 'N': case 'R': case 'L':
					metaword += cc;
					break;
				case 'Q':
					metaword += 'K';
					break;
				case 'V':
					metaword += 'F';
					break;
				case 'Z':
					metaword += 'S';
					break;
				case 'X':
					metaword += (x === 0) ? 'S' : 'KS';
					break;
				case 'K':
					if (x === 0 || pc !== 'C') {
						metaword += 'K';
					}
					break;
				case 'P':
					if (x + 1 <= wordlength && nc === 'H') {
						metaword += 'F';
					} else {
						metaword += 'P';
					}
					break;
				case 'Y':
					if (x + 1 > wordlength || isVowel(nc)) {
						metaword += 'Y';
					}
					break;
				case 'H':
					if (x === 0 || 'CSPTG'.indexOf(pc) === -1) {
						if (isVowel(nc) === true) {
							metaword += 'H';
						}
					}
					break;
				case 'S':
					if (x + 1 <= wordlength) {
						if (nc === 'H') {
							metaword += 'X';
						} else if (x + 2 <= wordlength && nc === 'I' && 'AO'.indexOf(nnc) !== -1) {
							metaword += 'X';
						} else {
							metaword += 'S';
						}
					} else {
						metaword += 'S';
					}
					break;
				case 'T':
					if (x + 1 <= wordlength) {
						if (nc === 'H') {
							metaword += '0';
						} else if (x + 2 <= wordlength && nc === 'I' && 'AO'.indexOf(nnc) !== -1) {
							metaword += 'X';
						} else {
							metaword += 'T';
						}
					} else {
						metaword += 'T';
					}
					break;
				case 'W':
					if (x + 1 <= wordlength && isVowel(nc)) {
						metaword += 'W';
					}
					break;
			}
		}
	}

	phones = parseInt(phones, 10);
	if (metaword.length > phones) {
		return metaword.substr(0, phones);
	}
	return metaword;
}

function similar_text (first, second, percent) {
	// http://kevin.vanzonneveld.net
	// +   original by: Rafał Kukawski (http://blog.kukawski.pl)
	// +   bugfixed by: Chris McMacken
	// +   added percent parameter by: Markus Padourek (taken from http://www.kevinhq.com/2012/06/php-similartext-function-in-javascript_16.html)
	// *     example 1: similar_text('Hello World!', 'Hello phpjs!');
	// *     returns 1: 7
	// *     example 2: similar_text('Hello World!', null);
	// *     returns 2: 0
	// *     example 3: similar_text('Hello World!', null, 1);
	// *     returns 3: 58.33
	if (first === null || second === null || typeof first === 'undefined' || typeof second === 'undefined') {
		return 0;
	}

	first += '';
	second += '';

	var pos1 = 0,
			pos2 = 0,
			max = 0,
			firstLength = first.length,
			secondLength = second.length,
			p, q, l, sum;

	max = 0;

	for (p = 0; p < firstLength; p++) {
		for (q = 0; q < secondLength; q++) {
			for (l = 0;
					(p + l < firstLength) && (q + l < secondLength) && (first.charAt(p + l) === second.charAt(q + l)); l++);
			if (l > max) {
				max = l;
				pos1 = p;
				pos2 = q;
			}
		}
	}

	sum = max;

	if (sum) {
		if (pos1 && pos2) {
			sum += this.similar_text(first.substr(0, pos2), second.substr(0, pos2));
		}

		if ((pos1 + max < firstLength) && (pos2 + max < secondLength)) {
			sum += this.similar_text(first.substr(pos1 + max, firstLength - pos1 - max), second.substr(pos2 + max, secondLength - pos2 - max));
		}
	}

	if (!percent) {
		return sum;
	} else {
		return (sum * 200) / (firstLength + secondLength);
	}
}

function soundex (str) {
	// http://kevin.vanzonneveld.net
	// +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
	// +    tweaked by: Jack
	// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// +   bugfixed by: Onno Marsman
	// +      input by: Brett Zamir (http://brett-zamir.me)
	// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// +   original by: Arnout Kazemier (http://www.3rd-Eden.com)
	// +    revised by: Rafał Kukawski (http://blog.kukawski.pl)
	// *     example 1: soundex('Kevin');
	// *     returns 1: 'K150'
	// *     example 2: soundex('Ellery');
	// *     returns 2: 'E460'
	// *     example 3: soundex('Euler');
	// *     returns 3: 'E460'
	str = (str + '').toUpperCase();
	if (!str) {
		return '';
	}
	var sdx = [0, 0, 0, 0],
			m = {
				B: 1,
				F: 1,
				P: 1,
				V: 1,
				C: 2,
				G: 2,
				J: 2,
				K: 2,
				Q: 2,
				S: 2,
				X: 2,
				Z: 2,
				D: 3,
				T: 3,
				L: 4,
				M: 5,
				N: 5,
				R: 6
			},
			i = 0,
			j, s = 0,
			c, p;

	while ((c = str.charAt(i++)) && s < 4) {
		if (j = m[c]) {
			if (j !== p) {
				sdx[s++] = p = j;
			}
		} else {
			s += i === 1;
			p = 0;
		}
	}

	sdx[0] = str.charAt(0);
	return sdx.join('');
}
;
if ( 'undefined' === typeof go_search_suggest ) {
	var go_search_suggest = {};
}//end if

( function( $ ) {
	'use strict';
	go_search_suggest.init = function init() {
		if ( 'undefined' === typeof scrib_authority_data ) {
			return;
		}//end if

		this.timer = null;

		var $search = $('.search-box, .nav-search input[name="s"]');

		$search.each( function() {
			var $el = $( this );

			var params = {
				custom_support: false,
				labels: {
					results: $el.data( 'go-search-suggest-label' ) || 'Search for:'
				},
				replace_field: false,
				taxonomies: scrib_authority_taxonomies
			};

			$el.attr( 'autocomplete', 'off' );

			var action = $el.closest( 'form' ).attr( 'action' );

			// make sure there's a trailing slash
			if ( '/' !== action.substr( -1 ) ) {
				action += '/';
			}//end if

			params.url = action + 'scriblio-authority-suggest/';

			$el.ScribAuthority( params );

			// if go_search_suggest.terms exist, pre-populate search terms
			if ( 'undefined' === typeof go_search_suggest.terms || ! go_search_suggest.terms.length ) {
				return;
			}//end if

			// identify the root
			var $root = $el.ScribAuthority( 'root', $el );

			// pre-populate the results
			$el.ScribAuthority( 'results', go_search_suggest.terms );

			var $results = $root.find('.scrib-authority-box-results');

			// when focusing the box, show any results that have been loaded
			$el.on( 'focus', function() {
				// if an unfocus was triggered but hasn't hidden the results yet, clear the timeout
				// to prevent a flash
				window.clearTimeout( go_search_suggest.timer );

				// "show" the results (this preps the result array appropriately)
				$el.ScribAuthority( 'show_results', $root );

				// _actually_ show the results because the API uses the value of the entry box to determine
				// if the results should ACTUALLY be shown.  We want to ignore that behavior and always show
				// a box
				$results.addClass('show');
			});

			// if focus on the box is lost, hide the results - but wait a moment
			$el.on( 'blur', function() {
				go_search_suggest.timer = setTimeout( function() {
					$el.ScribAuthority( 'hide_results', $root );
				}, 300 );
			});

			// if backspace or delete is pressed and there's nothing left in the box, re-populate with
			// the pre-populated terms
			$root.on( 'keyup.go-search-suggest', '.search-box', function( e ) {
				// backspace || delete
				if ( 8 === e.keyCode || 46 === e.keyCode ) {
					if ( '' === $.trim( $search.val() ) && go_search_suggest.terms.length > 0 ) {
						$results.find('.scrib-authority-box-result-category-results ul').html('');
						$el.ScribAuthority( 'results', go_search_suggest.terms );
					}//end if
				}//end if
			});
		});

		$(document).on( 'submit', 'form.search', function( e ) {
			e.preventDefault();
		});

		$(document).on( 'scriblio-authority-enter', 'form.search', function( e, data ) {
			var $form         = $(this);
			var action        = $form.attr('action');

			if ( $form.hasClass( 'prevent-keyword-search' ) ) {
				return;
			}//end if

			action += -1 === action.indexOf( '?' ) ? '?' : '&';
			action += 's=' + escape( data.value );

			document.location = action;
		});

		$(document).on( 'scriblio-authority-item-selected', 'form.search', function( e, data ) {
			if ( 'undefined' === typeof data.item || 0 === data.item.length ) {
				return;
			}//end if

			var term_data = data.item.data('origin-data');

			if ( 'undefined' === typeof term_data.taxonomy ) {
				return;
			}//end if

			var $form         = $(this);
			var action        = $form.attr('action');
			var taxonomy      = term_data.taxonomy;
			var taxonomy_name = 'post_tag' === taxonomy.name ? 'tag' : taxonomy.name;

			action += -1 === action.indexOf( '?' ) ? '?' : '&';
			action += taxonomy_name + '=' + data.item.data('slug');

			$form.find('.scrib-authority-box-entry').hide();

			$( document ).trigger( 'go_search_suggest.item.click', [ taxonomy_name, data.item.data('slug'), data.item ] );

			document.location = action;
		});

		var $message = $('<div class="suggest-message">For better results, try a Tag filter instead:</div>');
		var $message_singular = $('<div class="suggest-message">Were you looking for this?</div>');

		$('.selected-facets').before('<div class="facet-suggestions"><ul class="facets"/></div>');
		var $suggestions_container = $( '.facet-suggestions' );
		var $suggestions = $suggestions_container.find( '.facets' );
		var suggestions_html = '';
		var exact_match_html = '';

		$('.widget_scrib_searcheditor .selected-facets .facets .facet-container.first label').each( function() {
			var $label = $(this);
			
			if ( 'Search Keyword' === $.trim( $label.html() ) ) {
				var $facet = null;
				var facet  = null;
				var facet_metaphone = null;

				$facet = $label.closest( '.facet-container' ).find('.facet .term');

				facet = $.trim( $facet.html() );
				if ( 0 === facet.length ) {
					return;
				}

				// strip out any enclosing quotes because they shouldn't
				// be included when determining exact matches
				facet = facet.replace( /^("|'|“|‘)*|("|'|”|’)*$/g, '' );
				if ( 0 === facet.length ) {
					return;
				}

				facet_metaphone = metaphone( facet );
				var facet_soundex = soundex( facet );
				var facet_lower = facet.toLowerCase();

				var current_taxonomy = null;

				var facet_container_tpl = '' +
					'<li class="facet-container %%FACET_CLASS%%">' +
						'<label class="%%EXACT_MATCH_CLASS%%">%%TAXONOMY_LABEL%%</label>' +
						'<span class="separator %%EXACT_MATCH_CLASS%%">:</span>' +
						'<span class="facet">' +
							'<a href="%%TERM_URL%%" class="term">%%TERM%%</a>' +
							'<span class="inline-icon">' +
								'<a href="%%TERM_URL%%" class="goicon icon-search"></a>' +
							'</span>' +
						'</span>' +
					'</li>';

				// wait until we get a wijax-loaded event from the facets
				// container sidebar (widget-go-widget-areas-2) before
				// we try to come up with some suggestions
				$( document ).on( 'wijax-loaded', function( e, widget_id ) {
					if ( 'widget-go-widget-areas-2' !== widget_id ) {
						return;
					}

					$('.widget_scriblio_facets .term-link').each( function() {
						var $el = $(this).clone();
						$el.find('.count').remove();

						var term = $(this).closest('li').data('term');
						var taxonomy = $(this).closest('li').data('taxonomy');
						var taxonomy_label = $.trim( $(this).closest('.widget_scriblio_facets').find('.widget-title').html() );
						var term_url = $(this).closest('li').data('term-url');

						// we get term with .data() could return a non-string
						// object (maybe an integer) that we need to convert to
						// a string for further processing
						if ( 'string' !== typeof term ) {
							term = new String( term );
						}

						if ( term.toLowerCase() === facet_lower || metaphone( term ) === facet_metaphone || soundex( term ) === facet_soundex || similar_text( facet, term, 1 ) > 61 ) {
							var facet_class = '';

							if ( taxonomy !== current_taxonomy ) {
								current_taxonomy = taxonomy;
								facet_class = 'first';
							}//end if

							var term_tpl = facet_container_tpl
								.replace( /%%TAXONOMY_LABEL%%/g, taxonomy_label )
								.replace( /%%FACET_CLASS%%/g, facet_class )
								.replace( /%%TERM%%/g, term )
								.replace( /%%TERM_URL%%/g, term_url );

							// exact match?
							if ( term.toLowerCase() === facet_lower ) {
								// turn on the taxonomy label
								exact_match_html += term_tpl
									.replace( /%%EXACT_MATCH_CLASS%%/g, 'exact-match' );
							}
							else {
								suggestions_html += term_tpl
									.replace( /%%EXACT_MATCH_CLASS%%/g, '' );
							}
						}//end if
					});//end each

					if ( exact_match_html.length > 0 ) {
						suggestions_html = exact_match_html;
					}
					$suggestions.append( suggestions_html );

					var the_suggestions = suggestions_html.match( /li class="facet-container/g );
					var num_suggestions = ( null === the_suggestions ? 0 : the_suggestions.length );

					if ( num_suggestions > 0 ) {
						$suggestions_container.prepend( 1 === num_suggestions ? $message_singular : $message );
						$suggestions_container.show();
					}//end if

				});//end on wijax-loaded
			}//end if
		});//end each
	};//end init
})( jQuery );

jQuery( function( $ ) {
	'use strict';
	go_search_suggest.init();
} );
;
